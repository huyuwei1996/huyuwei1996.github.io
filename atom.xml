<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://huyuwei1996.github.io/</id>
    <title>Huyuwei的个人博客</title>
    <updated>2020-05-07T06:09:52.042Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://huyuwei1996.github.io/"/>
    <link rel="self" href="https://huyuwei1996.github.io/atom.xml"/>
    <subtitle>逆水行舟，不进则退</subtitle>
    <logo>https://huyuwei1996.github.io/images/avatar.png</logo>
    <icon>https://huyuwei1996.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, Huyuwei的个人博客</rights>
    <entry>
        <title type="html"><![CDATA[性能测试机环境搭建]]></title>
        <id>https://huyuwei1996.github.io/post/xing-neng-ce-shi-ji-huan-jing-da-jian/</id>
        <link href="https://huyuwei1996.github.io/post/xing-neng-ce-shi-ji-huan-jing-da-jian/">
        </link>
        <updated>2020-05-06T07:39:58.000Z</updated>
        <content type="html"><![CDATA[<p>备注：主机系统为CentOS 7</p>
<h1 id="建议先更新机器的yum源">建议先更新机器的yum源</h1>
<pre><code>sudo yum update -y
</code></pre>
<h1 id="修改主机名称">修改主机名称</h1>
<pre><code>sudo hostnamectl set-hostname PM133
echo &quot;127.0.0.1 PM133&quot; &gt;&gt; /etc/hosts
</code></pre>
<h1 id="安装java">安装Java</h1>
<h2 id="下载oracle-jdk18">下载Oracle JDK1.8</h2>
<p>由于现在需要登录下载，先从浏览器中点击下载后，将链接复制替换下面的地址</p>
<pre><code>wget -N --no-cookies --no-check-certificate --header &quot;Cookie: gpw_e24=http%3A%2F%2Fwww.oracle.com%2F; oraclelicense=accept-securebackup-cookie&quot; &quot;https://download.oracle.com/otn/java/jdk/8u251-b08/3d5a2bb8f8d4428bbe94aed7ec7ae784/jdk-8u251-linux-x64.rpm?AuthParam=xxxxxxxxxxxxxxxx&quot;
</code></pre>
<h2 id="安装jdk">安装JDK</h2>
<pre><code>sudo yum install jdk-8u251-linux-x64.rpm -y
</code></pre>
<h2 id="配置默认java">配置默认Java</h2>
<p>如果机器没有预装OpenJDK，就可以略过此步骤</p>
<pre><code>/usr/sbin/alternatives --config java
/usr/sbin/alternatives --config javac
</code></pre>
<p>命令输入后有对应的菜单选择，选择安装的Oracle JDK即可</p>
<h2 id="测试java安装情况">测试Java安装情况</h2>
<pre><code>java -version
javac -version
</code></pre>
<p>预期结果</p>
<pre><code>~ java -version
java version &quot;1.8.0_251&quot;
Java(TM) SE Runtime Environment (build 1.8.0_251-b08)
Java HotSpot(TM) 64-Bit Server VM (build 25.251-b08, mixed mode)
~ javac -version
javac 1.8.0_251
</code></pre>
<h1 id="安装gafana-server在仪表盘的服务器上安装">安装gafana-server（在仪表盘的服务器上安装）</h1>
<h2 id="下载和安装grafana">下载和安装grafana</h2>
<pre><code>wget https://dl.grafana.com/oss/release/grafana-6.7.3-1.x86_64.rpm
sudo yum install grafana-6.7.3-1.x86_64.rpm -y
</code></pre>
<h2 id="修改匿名可直接查看展示重启服务">修改匿名可直接查看展示&amp;重启服务</h2>
<pre><code>sudo vi /etc/grafana/grafana.ini
## 修改配置成如下状态：
[auth.anonymous]
# enable anonymous access
enabled = true

# specify organization name that should be used for unauthenticated users
;org_name = Main Org.

# specify role for unauthenticated users
org_role = Viewer

## 重启服务
sudo systemctl restart grafana-server
</code></pre>
<h1 id="添加influx源所有服务器">添加influx源（所有服务器）</h1>
<pre><code>cat &lt;&lt;EOF | sudo tee /etc/yum.repos.d/influxdb.repo
[influxdb]
name = InfluxDB Repository - RHEL \$releasever
baseurl = https://repos.influxdata.com/rhel/\$releasever/\$basearch/stable
enabled = 1
gpgcheck = 1
gpgkey = https://repos.influxdata.com/influxdb.key
EOF
</code></pre>
<h1 id="安装influxdb在负责收集数据的服务器上安装">安装influxdb（在负责收集数据的服务器上安装）</h1>
<h2 id="安装influxdb">安装influxdb</h2>
<pre><code>sudo yum install influxdb -y
</code></pre>
<h2 id="influxdb配置修改重启服务">influxdb配置修改&amp;重启服务</h2>
<pre><code>sudo vi /etc/influxdb/influxdb.conf
## 找到[[udp]]处添加udp配置
## 使用?[[udp]]回车直接找到这行
[[udp]]
  # High-traffic UDP
  enabled = true
  bind-address = &quot;:8089&quot; # the bind address
  database = &quot;udp&quot; # Name of the database that will be written to
  batch-size = 5000 # will flush if this many points get buffered
  batch-timeout = &quot;1s&quot; # will flush at least this often even if the batch-size is not reached
  batch-pending = 100 # number of batches that may be pending in memory
  read-buffer = 8388608 # (8*1024*1024) UDP read buffer size
## 重启服务
sudo systemctl restart influxdb
## 查看服务运行状态（详细）
sudo systemctl status influxdb -l
</code></pre>
<h1 id="安装telegraf在需要监控的服务器上安装">安装telegraf（在需要监控的服务器上安装）</h1>
<h2 id="安装telegraf">安装telegraf</h2>
<pre><code>sudo yum install telegraf -y
</code></pre>
<h2 id="telegraf配置修改重启服务">telegraf配置修改&amp;重启服务</h2>
<pre><code>sudo vi /etc/telegraf/telegraf.conf
## 使用111gg命令直接找到这行
### 监控数据通过http写到数据库的配置：
  # urls = [&quot;udp://10.9.8.129:8089&quot;]
  urls = [&quot;http://10.9.8.129:8086&quot;]
### 监控数据通过udp写到数据库的配置：
  urls = [&quot;udp://10.9.8.129:8089&quot;]
  # urls = [&quot;http://10.9.8.129:8086&quot;]
### 如果是监控机器写到自己的influxdb时，url写127.0.0.1，如：
 # urls = [&quot;udp://127.0.0.1:8089&quot;]
  urls = [&quot;http://127.0.0.1:8086&quot;]

## http写入时的数据库名称
database = &quot;telegraf&quot;前面去掉#号

## 添加netstat监控
## 使用?inputs.netstat回车直接找到这行
[[inputs.netstat]]前面去掉#号

## 修改net监控
## 使用?inputs.net]回车直接找到这行
[[inputs.net]]前面去掉#号
interfaces = [&quot;e*&quot;, &quot;lo&quot;]   # 修改网卡名称的匹配

## 重启服务
sudo systemctl restart telegraf
</code></pre>
<h1 id="关闭防火墙防火墙开机自启关掉后就可以访问grafana-server的3000端口了">关闭防火墙&amp;防火墙开机自启（关掉后就可以访问grafana-server的3000端口了）</h1>
<pre><code>## 查看防火墙
firewall-cmd --state
## 关闭firewall
systemctl stop firewalld.service
systemctl disable firewalld.service

## 或者开放3000端口
firewall-cmd --zone=public --add-port=3000/tcp --permanent
firewall-cmd --reload
firewall-cmd --zone=public --query-port=3000/tcp
firewall-cmd --zone=public --list-ports
</code></pre>
<h1 id="修改系统限制">修改系统限制</h1>
<h2 id="设定每个进程可以打开的最大文件描述符的数量">设定每个进程可以打开的最大文件描述符的数量</h2>
<pre><code>## dev下修改系统参数，切root就不用输dev密码了
sudo sudo su -

ulimit -n 65535
</code></pre>
<h2 id="修改内核参数">修改内核参数</h2>
<pre><code>sudo vi /etc/sysctl.conf

#表示开启SYN Cookies。当出现SYN等待队列溢出时，启用cookies来处理，可防范少量SYN攻击，默认为0，表示关闭
net.ipv4.tcp_syncookies = 1
#表示开启重用。允许将TIME-WAIT sockets重新用于新的TCP连接，默认为0，表示关闭
net.ipv4.tcp_tw_reuse = 1
#表示开启重用。允许将TIME-WAIT sockets重新用于新的TCP连接，默认为0，表示关闭
net.ipv4.tcp_tw_recycle = 1
#表示如果套接字由本端要求关闭，这个参数决定了它保持在FIN-WAIT-2状态的时间
net.ipv4.tcp_fin_timeout=30
#表示当keepalive起用的时候，TCP发送keepalive消息的频度。缺省是2小时，改为20分钟
net.ipv4.tcp_keepalive_time = 1200 
#表示用于向外连接的端口范围。缺省情况下很小：32768到61000，改为1024到65000
net.ipv4.ip_local_port_range = 1024 65000 
#表示SYN队列的长度，默认为1024，加大队列长度为8192，可以容纳更多等待连接的网络连接数
net.ipv4.tcp_max_syn_backlog = 8192 
#表示系统同时保持TIME_WAIT套接字的最大数量，如果超过这个数字，TIME_WAIT套接字将立刻被清除并打印警告信息。默认为180000，改为5000。对于Apache、Nginx等服务器，上几行的参数可以很好地减少TIME_WAIT套接字数量，但是对于 Squid，效果却不大。此项参数可以控制TIME_WAIT套接字的最大数量，避免Squid服务器被大量的TIME_WAIT套接字拖死。
net.ipv4.tcp_max_tw_buckets = 5000

## 立即生效（免重启）
sudo sysctl -p
</code></pre>
<h2 id="提高线程的使用限制">提高线程的使用限制</h2>
<pre><code>echo 999999 &gt; /proc/sys/kernel/pid_max
echo 1999999 &gt; /proc/sys/vm/max_map_count
</code></pre>
<h1 id="安装jmeter">安装Jmeter</h1>
<h2 id="下载jmeter这里下载最新的521">下载Jmeter（这里下载最新的5.2.1）</h2>
<pre><code>## 这里我们放在soft目录下
mkdir soft &amp;&amp; cd soft
wget -N https://mirror.bit.edu.cn/apache//jmeter/binaries/apache-jmeter-5.2.1.zip
</code></pre>
<h2 id="解压配置环境变量">解压&amp;配置环境变量</h2>
<pre><code>unzip apache-jmeter-5.2.1.zip
## 如果提示不能用unzip命令
sudo yum install zip unzip -y

## 修改环境变量&amp;激活环境变量（非root用户的，JMETER_HOME类似/home/dev/soft/apache-jmeter-5.2.1）
sudo vi /etc/profile

export JMETER_HOME=/root/soft/apache-jmeter-5.2.1
export CLASSPATH=$JMETER_HOME/lib/ext/ApacheJMeter_core.jar:$JMETER_HOME/lib/jorphan.jar:$CLASSPATH
export PATH=$JMETER_HOME/bin:$PATH

source /etc/profile
</code></pre>
<h2 id="测试jmeter安装情况">测试Jmeter安装情况</h2>
<pre><code>jmeter -v
</code></pre>
<p>预期结果</p>
<pre><code>~ jmeter -v
    _    ____   _    ____ _   _ _____       _ __  __ _____ _____ _____ ____
   / \  |  _ \ / \  / ___| | | | ____|     | |  \/  | ____|_   _| ____|  _ \
  / _ \ | |_) / _ \| |   | |_| |  _|    _  | | |\/| |  _|   | | |  _| | |_) |
 / ___ \|  __/ ___ \ |___|  _  | |___  | |_| | |  | | |___  | | | |___|  _ &lt;
/_/   \_\_| /_/   \_\____|_| |_|_____|  \___/|_|  |_|_____| |_| |_____|_| \_\ 5.2.1

Copyright (c) 1999-2019 The Apache Software Foundation
</code></pre>
<h2 id="修改jmeter的jvm参数">修改Jmeter的JVM参数</h2>
<h3 id="修改jmetersh和jmeterwin修改jmeterbat">修改jmeter.sh和jmeter，win修改jmeter.bat</h3>
<pre><code>cd soft/apache-jmeter-5.2.1/bin
vi jmeter.sh
vi jmeter
</code></pre>
<h3 id="heap最多设置为物理内存的一半8g机器设置4g16g机器设置8g">heap最多设置为物理内存的一半，8G机器设置4G，16G机器设置8G</h3>
<pre><code>JVM_ARGS=&quot;-Xms4G -Xmx4G -Xmn512m&quot;
JVM_ARGS=&quot;-Xms8G -Xmx8G -Xmn512m&quot;
</code></pre>
<h3 id="修改每线程占用的栈空间目前没改">修改每线程占用的栈空间（目前没改）</h3>
<pre><code>JVM_ARGS=&quot;-XX:ThreadStackSize=400k&quot;
</code></pre>
<p>每线程使用400KB的栈空间，比缺省的1MB节省了约60%，但是实际上在运行过程中，栈空间的使用也不完全是线性的，具体的节省下来的栈空间需要通过试验。</p>
<h2 id="修改jmeter-server">修改jmeter-server</h2>
<h3 id="先用ifconfig找下网卡名称比如是em1win修改jmeter-serverbat">先用ifconfig找下网卡名称，比如是em1，win修改jmeter-server.bat</h3>
<pre><code>vi jmeter-server

# 添加下面内容到最后一行的前面即可
ip=`ifconfig em1 | awk -F &quot;[ :]+&quot; 'NR==2{print $3}'`
RMI_HOST_DEF=-Djava.rmi.server.hostname=$ip
</code></pre>
<h2 id="修改主控机jmeterproperties">修改主控机jmeter.properties</h2>
<pre><code>vi jmeter.properties

## 258gg找到这行，如果有多台代理机，这里需要把所有的代理机的IP地址和端口号都加入进来
remote_hosts=127.0.0.1,10.9.8.133
server.rmi.ssl.disable=true
</code></pre>
<h2 id="slave机器jmeter-server启动关闭脚本jmeter-server自启动">slave机器：jmeter-server启动/关闭脚本&amp;jmeter-server自启动</h2>
<p>例如133机器：（默认root用户时）</p>
<pre><code>## 启动脚本
vi /root/soft/startup.sh

#!/bin/bash
source /etc/profile
cd /root/
rm -f jmeter-server.log
jmeter-server &amp;
exit
</code></pre>
<p>例如108机器：（默认dev用户时）</p>
<pre><code>## 启动脚本
vi /home/dev/soft/startup.sh

#!/bin/bash
source /etc/profile
cd /home/dev/
rm -f jmeter-server.log
jmeter-server &amp;
exit
</code></pre>
<p>下面路径根据用户参考上面例子</p>
<pre><code>## 关闭脚本
vi /root/soft/shutdown.sh

#!/bin/bash
str=`ps -ef | grep jmeter-server | grep -v &quot;grep&quot;|awk '{print $2}'`
kill -9 $str
if [ &quot;$?&quot; -eq 0 ]; then
	echo &quot;killed pid is &quot;$str
    echo &quot;kill success&quot;
else
    echo &quot;kill failed&quot;
fi

## 添加自启动服务
sudo vi /usr/lib/systemd/system/jmeter-server.service

[Unit]
Description=jmeter-server project
After=jmeter-server.service
  
[Service]
Type=forking
User=root
Group=root
ExecStart=/root/soft/startup.sh
ExecReload=
ExecStop=/root/soft/shutdown.sh
PrivateTmp=true
  
[Install]
WantedBy=multi-user.target

## 赋权限，激活服务（设置自启动）
sudo chmod 754 /usr/lib/systemd/system/jmeter-server.service
sudo systemctl enable jmeter-server.service

## 其他相关命令
sudo systemctl start jmeter-server  # 启动服务
sudo systemctl stop jmeter-server # 停止服务
sudo systemctl status jmeter-server # 查看服务运行
sudo systemctl restart jmeter-server # 重启服务

sudo systemctl disable jmeter-server.service # 禁用服务自启动
</code></pre>
<h2 id="主控机执行时">主控机执行时：</h2>
<pre><code>jmeter -n -t test.jmx -R server1IP,server2IP
## 例：
jmeter -n -t test.jmx -R 10.9.8.133
</code></pre>
<h1 id="公司机器切root用户方式">公司机器切root用户方式</h1>
<pre><code>## 不知道怎么配置的，反正需要2个sudo
sudo sudo su -
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[iterm2配置lrzsz]]></title>
        <id>https://huyuwei1996.github.io/post/iterm2-pei-zhi-lrzsz/</id>
        <link href="https://huyuwei1996.github.io/post/iterm2-pei-zhi-lrzsz/">
        </link>
        <updated>2020-04-30T06:28:48.000Z</updated>
        <content type="html"><![CDATA[<h1 id="下载脚本">下载脚本</h1>
<p>将iterm2-send-zmodem.sh &amp; iterm2-recv-zmodem.sh放到/usr/local/bin/</p>
<pre><code>git clone https://github.com/huyuwei1996/iterm2-zmodem.git
cd iterm2-zmodem
cp *.sh /usr/local/bin
</code></pre>
<h1 id="配置iterm2-trigger">配置iterm2 Trigger</h1>
<p>选择Profiles &gt; Default &gt; Advanced &gt; Triggers &gt; Edit</p>
<h2 id="发送-sz">发送 sz</h2>
<pre><code>Regular expression: rz waiting to receive.\*\*B0100 (注意这里是这样)
Action: Run Silent Coprocess
Parameters: /usr/local/bin/iterm2-send-zmodem.sh
</code></pre>
<h2 id="接收-rz">接收 rz</h2>
<pre><code>Regular expression:\*\*B00000000000000
Action: Run Silent Coprocess
Parameters: /usr/local/bin/iterm2-recv-zmodem.sh
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[JPype1 - python2.7下mac和win安装解决]]></title>
        <id>https://huyuwei1996.github.io/post/jpype1-python27-xia-mac-he-win-an-zhuang-jie-jue/</id>
        <link href="https://huyuwei1996.github.io/post/jpype1-python27-xia-mac-he-win-an-zhuang-jie-jue/">
        </link>
        <updated>2020-04-13T07:29:21.000Z</updated>
        <content type="html"><![CDATA[<h1 id="直接指定版本安装">直接指定版本安装</h1>
<p>python2.7就安装0.7.1及其以下版本</p>
<pre><code>pip2 install jpype1==0.7.1
or
pip2 install jpype1==0.7.0
</code></pre>
<h2 id="win通过压缩包安装">win通过压缩包安装</h2>
<p><code>pip2 install jpype1</code>安装失败<br>
在<a href="https://www.lfd.uci.edu/~gohlke/pythonlibs/#jpype">https://www.lfd.uci.edu/~gohlke/pythonlibs/#jpype</a> 下载cp27也就是对应python2.7的<br>
<img src="https://huyuwei1996.github.io//post-images/1586763262234.png" alt="" loading="lazy"><br>
然后使用<code>pip2 install JPype1-0.7.1-cp27-cp27m-win_amd64.whl</code>安装</p>
<h2 id="mac通过编译安装">mac通过编译安装</h2>
<p><code>pip2 install jpype1</code>安装失败<br>
在<a href="https://github.com/jpype-project/jpype/releases">https://github.com/jpype-project/jpype/releases</a> 下载v0.7.1的Source code<br>
(zip)<br>
因为0.7.2开始不支持python2.7，所以安装时候会一直报错。<br>
这里选择下载源码解压后，直接编译安装</p>
<pre><code>cd JPype1-0.7.1
python2 setup.py install
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[记一次libimobiledevice安装问题]]></title>
        <id>https://huyuwei1996.github.io/post/ji-yi-ci-libimobiledevice-an-zhuang-wen-ti/</id>
        <link href="https://huyuwei1996.github.io/post/ji-yi-ci-libimobiledevice-an-zhuang-wen-ti/">
        </link>
        <updated>2020-04-13T07:12:26.000Z</updated>
        <content type="html"><![CDATA[<p><img src="https://huyuwei1996.github.io//post-images/1586762260492.png" alt="" loading="lazy"><br>
直接记录下结果吧，图中3f64bbdc857512944b5bc7bb36f4d59191c25d14一直编译报错，afc.c的问题。</p>
<pre><code>brew install -v --HEAD libimobiledevice
# 安装失败后，切换上一个commit
cd /Users/huyuwei/Library/Caches/Homebrew/libimobiledevice--git
git checkout c0576790378daa45d43335d44c5caff04c270c94
brew install gnutls
brew install libgcrypt
./autogen.sh --disable-openssl
make
make install
</code></pre>
<p>解决经过：</p>
<pre><code>brew install -v --HEAD libimobiledevice
# 安装新版时候，中间安装了依赖python@3.8，和openssl@1.1，brew自动安装失败后，尝试以下命令依然失败
brew install -v --HEAD --fetch --build-from-source libimobiledevice
# 后面打算手动编译，链接相关依赖库
cd /Users/huyuwei/Library/Caches/Homebrew/libimobiledevice--git
export LDFLAGS=&quot;-L/usr/local/opt/python@3.8/lib:$LDFLAGS&quot;
export LDFLAGS=&quot;-L/usr/local/opt/openssl@1.1/lib:$LDFLAGS&quot;
export CPPFLAGS=&quot;-I/usr/local/opt/openssl@1.1/include&quot;
./autogen.sh
# 提示openssl版本不对(如下)，可能是这里LDFLAGS设置的问题，不太会弄
checking for openssl &gt;= 0.9.8... no
configure: error: OpenSSL support explicitly requested but OpenSSL could not be found
# 最后找到一种方式
brew install gnutls
brew install libgcrypt
./autogen.sh --disable-openssl
make
make install
</code></pre>
<p>然后ideviceinstaller这个终于恢复正常了<br>
<img src="https://huyuwei1996.github.io//post-images/1586763744560.png" alt="" loading="lazy"></p>
<p>第二天的新commit解决了这个问题。cf5a60d75c2108261a6e848b352f798c1422349c<br>
这么倒霉的事情刚好遇到了，我还硬装上了，太累了🙁</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Sublime Text常用插件记录]]></title>
        <id>https://huyuwei1996.github.io/post/sublime-text-chang-yong-cha-jian-ji-lu/</id>
        <link href="https://huyuwei1996.github.io/post/sublime-text-chang-yong-cha-jian-ji-lu/">
        </link>
        <updated>2020-04-10T03:40:25.000Z</updated>
        <content type="html"><![CDATA[<h6 id="常用package">常用Package</h6>
<blockquote>
<p>Package Control<br>
ConvertToUTF8(支持GBK)<br>
Codecs33(支持GB2312)<br>
HTML-CSS-JS Prettify<br>
Keymaps<br>
MarkdownTOC<br>
Nodejs<br>
Python 3<br>
PackageResourceViewer<br>
SideBarEnhancements<br>
Material Theme<br>
Theme - Monokai Pro</p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[python判断系统类型]]></title>
        <id>https://huyuwei1996.github.io/post/python-pan-duan-xi-tong-lei-xing/</id>
        <link href="https://huyuwei1996.github.io/post/python-pan-duan-xi-tong-lei-xing/">
        </link>
        <updated>2020-04-10T03:40:12.000Z</updated>
        <content type="html"><![CDATA[<h2 id="osname">os.name</h2>
<p>该变量返回当前操作系统的类型</p>
<pre><code class="language-python">import os
print(os.name)
</code></pre>
<table>
<thead>
<tr>
<th style="text-align:center">系统</th>
<th style="text-align:center">返回值</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">linux</td>
<td style="text-align:center">posix</td>
</tr>
<tr>
<td style="text-align:center">windows</td>
<td style="text-align:center">nt</td>
</tr>
<tr>
<td style="text-align:center">java虚拟机</td>
<td style="text-align:center">java</td>
</tr>
</tbody>
</table>
<h2 id="sysplatform">sys.platform</h2>
<p>该变量返回当前系统的平台标识</p>
<pre><code class="language-python">import sys
print(sys.platform)
</code></pre>
<table>
<thead>
<tr>
<th style="text-align:center">系统</th>
<th style="text-align:center">返回值</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">linux</td>
<td style="text-align:center">linux</td>
</tr>
<tr>
<td style="text-align:center">windows</td>
<td style="text-align:center">win32</td>
</tr>
<tr>
<td style="text-align:center">windows/cygwin</td>
<td style="text-align:center">cygwin</td>
</tr>
<tr>
<td style="text-align:center">mac os x</td>
<td style="text-align:center">darwin</td>
</tr>
</tbody>
</table>
<h2 id="platformsystem">platform.system()</h2>
<p>返回当前操作系统的名字</p>
<pre><code class="language-python">import platform
print(platform.system())
</code></pre>
<p>例如Linux，Windows，Java，Darwin，...</p>
<pre><code>platform.platform()     #获取操作系统名称及版本号，如'Darwin-19.2.0-x86_64-i386-64bit'

platform.version()        #获取操作系统版本号，如'Darwin Kernel Version 19.2.0: Sat Nov  9 03:47:04 PST 2019; root:xnu-6153.61.1~20/RELEASE_X86_64'

platform.architecture()    #获取操作系统的位数，如('64bit', '')

platform.machine()     #计算机类型，如'x86_64'

platform.node()          #计算机的网络名称

platform.processor()    #计算机处理器信息，如'i386'

platform.uname()        #包含上面所有的信息汇总
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[oh-my-zsh安装]]></title>
        <id>https://huyuwei1996.github.io/post/oh-my-zsh-an-zhuang/</id>
        <link href="https://huyuwei1996.github.io/post/oh-my-zsh-an-zhuang/">
        </link>
        <updated>2020-04-10T03:39:41.000Z</updated>
        <content type="html"><![CDATA[<h2 id="安装步骤">安装步骤</h2>
<ol>
<li>zsh安装</li>
<li>oh-my-zsh安装、高亮&amp;自动补全插件安装</li>
<li>autojump插件安装</li>
</ol>
<h2 id="安装脚本">安装脚本</h2>
<p>MacOS:<br>
mac自带zsh</p>
<pre><code>sh -c &quot;$(curl -fsSL https://raw.githubusercontent.com/ohmyzsh/ohmyzsh/master/tools/install.sh)&quot;

git clone https://github.com/zsh-users/zsh-autosuggestions ${ZSH_CUSTOM:-~/.oh-my-zsh/custom}/plugins/zsh-autosuggestions
git clone https://github.com/zsh-users/zsh-syntax-highlighting.git ${ZSH_CUSTOM:-~/.oh-my-zsh/custom}/plugins/zsh-syntax-highlighting

brew install autojump

sed -i &quot;&quot; &quot;s/plugins=(git)/plugins=(git zsh-autosuggestions zsh-syntax-highlighting autojump)/g&quot; ~/.zshrc
source ~/.zshrc
</code></pre>
<p>Ubuntu:</p>
<pre><code>sudo apt update -y
sudo apt install zsh -y
sudo apt install git -y

sh -c &quot;$(curl -fsSL https://raw.githubusercontent.com/ohmyzsh/ohmyzsh/master/tools/install.sh)&quot;

git clone https://github.com/zsh-users/zsh-autosuggestions ${ZSH_CUSTOM:-~/.oh-my-zsh/custom}/plugins/zsh-autosuggestions
git clone https://github.com/zsh-users/zsh-syntax-highlighting.git ${ZSH_CUSTOM:-~/.oh-my-zsh/custom}/plugins/zsh-syntax-highlighting

sudo apt install autojump -y

sed -i &quot;s/plugins=(git)/plugins=(git zsh-autosuggestions zsh-syntax-highlighting autojump)/g&quot; ~/.zshrc
source ~/.zshrc
</code></pre>
<p>CentOS:</p>
<pre><code>sudo yum update -y
sudo yum install zsh -y
sudo yum install git -y

sh -c &quot;$(curl -fsSL https://raw.githubusercontent.com/ohmyzsh/ohmyzsh/master/tools/install.sh)&quot;

git clone https://github.com/zsh-users/zsh-autosuggestions ${ZSH_CUSTOM:-~/.oh-my-zsh/custom}/plugins/zsh-autosuggestions
git clone https://github.com/zsh-users/zsh-syntax-highlighting.git ${ZSH_CUSTOM:-~/.oh-my-zsh/custom}/plugins/zsh-syntax-highlighting

sudo yum install -y autojump-zsh

sed -i &quot;s/plugins=(git)/plugins=(git zsh-autosuggestions zsh-syntax-highlighting autojump)/g&quot; ~/.zshrc
source ~/.zshrc
</code></pre>
<h3 id="其他配置">其他配置</h3>
<p>如果没有切换shell成功<br>
<code>chsh -s /bin/zsh</code><br>
常显主机名hostname<br>
<code>echo &quot;PROMPT=%m\ \$PROMPT&quot; &gt;&gt; .zshrc</code></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Mac launchctl 启动进程]]></title>
        <id>https://huyuwei1996.github.io/post/mac-launchctl-qi-dong-jin-cheng/</id>
        <link href="https://huyuwei1996.github.io/post/mac-launchctl-qi-dong-jin-cheng/">
        </link>
        <updated>2020-04-10T03:39:04.000Z</updated>
        <content type="html"><![CDATA[<h1>plist文件分布</h1>
<pre><code class="">/System/Library/LaunchDaemons/ （System-wide daemons provided by OS X）
其中 apache的httpd程序启动配置文件 org.apache.httpd.plist 就在这里。

/System/Library/LaunchAgents/ （由Mac OS X为用户定义的任务项）

/Library/LaunchDaemons （由管理员定义的守护进程任务项 ）

/Library/LaunchAgents （由管理员为用户定义的任务项 ）
如果放到/Library/LaunchAgents/下面的话，就是一开机就启动哦～

~/Library/LaunchAgents （ 由用户自己定义的任务项 ）
</code></pre>
<h1>launchctl 常用命令</h1>
<pre><code class="">1.显示当前的启动脚本
launchctl list

2.开机时自动启动Apache服务器
sudo launchctl load -w /System/Library/LaunchDaemons/org.apache.httpd.plist

3.设置开机启动并立即启动改服务
launchctl load -w   **.pist 

4. 设置开机启动但不立即启动服务 
launchctl load **.pist 

5. 停止正在运行的启动脚本
sudo launchctl unload [path/to/script]
6. 再加上-w选项即可去除开机启动
sudo launchctl unload -w [path/to/script]
</code></pre>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Linux内核参数优化]]></title>
        <id>https://huyuwei1996.github.io/post/linux-nei-he-can-shu-you-hua/</id>
        <link href="https://huyuwei1996.github.io/post/linux-nei-he-can-shu-you-hua/">
        </link>
        <updated>2019-11-01T07:22:54.000Z</updated>
        <summary type="html"><![CDATA[<blockquote>
<p>转自——高并发情况下Linux系统及kernel参数优化：<a href="https://www.linuxidc.com/Linux/2018-08/153369.htm">https://www.linuxidc.com/Linux/2018-08/153369.htm</a></p>
<p>调整了一下方便自己查看</p>
</blockquote>
]]></summary>
        <content type="html"><![CDATA[<blockquote>
<p>转自——高并发情况下Linux系统及kernel参数优化：<a href="https://www.linuxidc.com/Linux/2018-08/153369.htm">https://www.linuxidc.com/Linux/2018-08/153369.htm</a></p>
<p>调整了一下方便自己查看</p>
</blockquote>
<!-- more -->
<p>众所周知在默认参数情况下Linux对高并发支持并不好，主要受限于单进程最大打开文件数限制、内核TCP参数方面和IO事件分配机制等。下面就从几方面来调整使Linux系统能够支持高并发环境。</p>
<h4 id="iptables相关">Iptables相关</h4>
<p>如非必须，关掉或卸载iptables防火墙，并阻止kernel加载iptables模块。这些模块会影响并发性能。</p>
<h4 id="单进程最大打开文件数限制">单进程最大打开文件数限制</h4>
<p>一般的发行版，限制单进程最大可以打开1024个文件，这是远远不能满足高并发需求的，调整过程如下:</p>
<p>在#号提示符下敲入:</p>
<pre><code># ulimit –n 65535
</code></pre>
<p>将root启动的单一进程的最大可以打开的文件数设置为65535个。如果系统回显类似于“Operationnotpermitted”之类的话，说明上述限制修改失败，实际上是因为在中指定的数值超过了Linux系统对该用户打开文件数的软限制或硬限制。因此，就需要修改Linux系统对用户的关于打开文件数的软限制和硬限制。</p>
<p>第一步，修改limits.conf文件，并添加：</p>
<pre><code># vim /etc/security/limits.conf
* soft nofile 65535
* hard nofile 65535
</code></pre>
<p>可以写成</p>
<pre><code>* - nofile 65535
</code></pre>
<p>其中'*'号表示修改所有用户的限制；soft或hard指定要修改软限制还是硬限制；65536则指定了想要修改的新的限制值，即最大打开文件数(请注意软限制值要小于或等于硬限制)。修改完后保存文件。</p>
<p>第二步，修改/etc/pam.d/login文件，在文件中添加如下行：</p>
<pre><code># vim /etc/pam.d/login
session required /lib/security/pam_limits.so

# 64位系统应该为这个路径
session required /lib64/security/pam_limits.so
</code></pre>
<p>这是告诉Linux在用户完成系统登录后，应该调用pam_limits.so模块来设置系统对该用户可使用的各种资源数量的最大限制(包括用户可打开的最大文件数限制)，而pam_limits.so模块就会从/etc/security/limits.conf文件中读取配置来设置这些限制值。修改完后保存此文件。</p>
<p>第三步，查看Linux系统级的最大打开文件数限制，使用如下命令：</p>
<pre><code># cat /proc/sys/fs/file-max
32568
</code></pre>
<p>这表明这台Linux系统最多允许同时打开(即包含所有用户打开文件数总和)32568个文件，是Linux系统级硬限制，所有用户级的打开文件数限制都不应超过这个数值。通常这个系统级硬限制是Linux系统在启动时根据系统硬件资源状况计算出来的最佳的最大同时打开文件数限制，如果没有特殊需要，不应该修改此限制，除非想为用户级打开文件数限制设置超过此限制的值。修改此硬限制的方法是修改/etc/sysctl.conf文件内fs.file-max= 131072</p>
<p>这是让Linux在启动完成后强行将系统级打开文件数硬限制设置为131072。修改完后保存此文件。</p>
<p>完成上述步骤后重启系统，一般情况下就可以将Linux系统对指定用户的单一进程允许同时打开的最大文件数限制设为指定的数值。如果重启后用ulimit-n命令查看用户可打开文件数限制仍然低于上述步骤中设置的最大值，这可能是因为在用户登录脚本/etc/profile中使用ulimit-n命令已经将用户可同时打开的文件数做了限制。由于通过ulimit-n修改系统对用户可同时打开文件的最大数限制时，新修改的值只能小于或等于上次ulimit-n设置的值，因此想用此命令增大这个限制值是不可能的。所以，如果有上述问题存在，就只能去打开/etc/profile脚本文件，在文件中查找是否使用了ulimit-n限制了用户可同时打开的最大文件数量，如果找到，则删除这行命令，或者将其设置的值改为合适的值，然后保存文件，用户退出并重新登录系统即可。</p>
<p>通过上述步骤，就为支持高并发TCP连接处理的通讯处理程序解除关于打开文件数量方面的系统限制。</p>
<h4 id="内核tcp参数方面">内核TCP参数方面</h4>
<p>Linux系统下，TCP连接断开后，会以TIME_WAIT状态保留一定的时间，然后才会释放端口。当并发请求过多的时候，就会产生大量的TIME_WAIT状态的连接，无法及时断开的话，会占用大量的端口资源和服务器资源。这个时候我们可以优化TCP的内核参数，来及时将TIME_WAIT状态的端口清理掉。</p>
<p>下面介绍的方法只对拥有大量TIME_WAIT状态的连接导致系统资源消耗有效，如果不是这种情况下，效果可能不明显。可以使用netstat命令去查TIME_WAIT状态的连接状态，输入下面的组合命令，查看当前TCP连接的状态和对应的连接数量：</p>
<pre><code># netstat -n | awk '/^tcp/ {++S[$NF]} END {for(a in S) print a, S[a]}'
</code></pre>
<p>这个命令会输出类似下面的结果：</p>
<p>LAST_ACK16<br>
SYN_RECV348<br>
ESTABLISHED70<br>
FIN_WAIT1229<br>
FIN_WAIT230<br>
CLOSING33<br>
TIME_WAIT18098</p>
<p>我们只用关心TIME_WAIT的个数，在这里可以看到，有18000多个TIME_WAIT，这样就占用了18000多个端口。要知道端口的数量只有65535个，占用一个少一个，会严重的影响到后继的新连接。这种情况下，我们就有必要调整下Linux的TCP内核参数，让系统更快的释放TIME_WAIT连接。</p>
<p>编辑配置文件:/etc/sysctl.conf，在这个文件中，加入下面的几行内容：</p>
<pre><code># vim /etc/sysctl.conf
net.ipv4.tcp_syncookies= 1
net.ipv4.tcp_tw_reuse= 1
net.ipv4.tcp_tw_recycle= 1
net.ipv4.tcp_fin_timeout= 30
</code></pre>
<p>输入下面的命令，让内核参数生效：</p>
<pre><code># sysctl -p
</code></pre>
<p>简单的说明上面的参数的含义：</p>
<pre><code>net.ipv4.tcp_syncookies= 1
#表示开启SYNCookies。当出现SYN等待队列溢出时，启用cookies来处理，可防范少量SYN***，默认为0，表示关闭；

net.ipv4.tcp_tw_reuse= 1
#表示开启重用。允许将TIME-WAITsockets重新用于新的TCP连接，默认为0，表示关闭；

net.ipv4.tcp_tw_recycle= 1
#表示开启TCP连接中TIME-WAITsockets的快速回收，默认为0，表示关闭；

net.ipv4.tcp_fin_timeout
#修改系統默认的TIMEOUT 时间。
</code></pre>
<p>在经过这样的调整之后，除了会进一步提升服务器的负载能力之外，还能够防御小流量程度的DoS、CC和SYN***。</p>
<p>此外，如果你的连接数本身就很多，我们可以再优化一下TCP的可使用端口范围，进一步提升服务器的并发能力。依然是往上面的参数文件中，加入下面这些配置：</p>
<pre><code>net.ipv4.tcp_keepalive_time= 1200
net.ipv4.ip_local_port_range= 1024 65535
net.ipv4.tcp_max_syn_backlog= 8192
net.ipv4.tcp_max_tw_buckets= 5000
</code></pre>
<p>这几个参数，建议只在流量非常大的服务器上开启，会有显著的效果。一般的流量小的服务器上，没有必要去设置这几个参数。</p>
<pre><code>net.ipv4.tcp_keepalive_time= 1200
#表示当keepalive起用的时候，TCP发送keepalive消息的频度。缺省是2小时，改为20分钟。

net.ipv4.ip_local_port_range= 1024 65535
#表示用于向外连接的端口范围。缺省情况下很小，改为1024到65535。

net.ipv4.tcp_max_syn_backlog= 8192
#表示SYN队列的长度，默认为1024，加大队列长度为8192，可以容纳更多等待连接的网络连接数。

net.ipv4.tcp_max_tw_buckets= 5000
#表示系统同时保持TIME_WAIT的最大数量，如果超过这个数字，TIME_WAIT将立刻被清除并打印警告信息。默认为180000，改为5000。此项参数可以控制TIME_WAIT的最大数量，只要超出了。
</code></pre>
<h4 id="内核其他tcp参数说明">内核其他TCP参数说明：</h4>
<pre><code>net.ipv4.tcp_max_syn_backlog= 65536
#记录的那些尚未收到客户端确认信息的连接请求的最大值。对于有128M内存的系统而言，缺省值是1024，小内存的系统则是128。

net.core.netdev_max_backlog= 32768
#每个网络接口接收数据包的速率比内核处理这些包的速率快时，允许送到队列的数据包的最大数目。

net.core.somaxconn= 32768
#例如web应用中listen函数的backlog默认会给我们内核参数的net.core.somaxconn限制到128，而nginx定义的NGX_LISTEN_BACKLOG默认为511，所以有必要调整这个值。

net.core.wmem_default= 8388608
net.core.rmem_default= 8388608
net.core.rmem_max= 16777216          #最大socket读buffer,可参考的优化值:873200
net.core.wmem_max= 16777216          #最大socket写buffer,可参考的优化值:873200
net.ipv4.tcp_timestsmps= 0
#时间戳可以避免序列号的卷绕。一个1Gbps的链路肯定会遇到以前用过的序列号。时间戳能够让内核接受这种“异常”的数据包。这里需要将其关掉。

net.ipv4.tcp_synack_retries= 2
#为了打开对端的连接，内核需要发送一个SYN并附带一个回应前面一个SYN的ACK。也就是所谓三次握手中的第二次握手。这个设置决定了内核放弃连接之前发送SYN+ACK包的数量。

net.ipv4.tcp_syn_retries= 2
#在内核放弃建立连接之前发送SYN包的数量。

#net.ipv4.tcp_tw_len= 1
net.ipv4.tcp_tw_reuse= 1
# 开启重用。允许将TIME-WAITsockets重新用于新的TCP连接。

net.ipv4.tcp_wmem= 8192 436600 873200
# TCP写buffer,可参考的优化值:8192 436600 873200

net.ipv4.tcp_rmem  = 32768 436600 873200
# TCP读buffer,可参考的优化值:32768 436600 873200

net.ipv4.tcp_mem= 94500000 91500000 92700000
# 同样有3个值,意思是:
net.ipv4.tcp_mem[0]:低于此值，TCP没有内存压力。
net.ipv4.tcp_mem[1]:在此值下，进入内存压力阶段。
net.ipv4.tcp_mem[2]:高于此值，TCP拒绝分配socket。
上述内存单位是页，而不是字节。可参考的优化值是:7864321048576 1572864

net.ipv4.tcp_max_orphans= 3276800
#系统中最多有多少个TCP套接字不被关联到任何一个用户文件句柄上。
如果超过这个数字，连接将即刻被复位并打印出警告信息。
这个限制仅仅是为了防止简单的DoS***，不能过分依靠它或者人为地减小这个值，
更应该增加这个值(如果增加了内存之后)。

net.ipv4.tcp_fin_timeout= 30
#如果套接字由本端要求关闭，这个参数决定了它保持在FIN-WAIT-2状态的时间。对端可以出错并永远不关闭连接，甚至意外当机。缺省值是60秒。2.2 内核的通常值是180秒，你可以按这个设置，但要记住的是，即使你的机器是一个轻载的WEB服务器，也有因为大量的死套接字而内存溢出的风险，FIN-WAIT-2的危险性比FIN-WAIT-1要小，因为它最多只能吃掉1.5K内存，但是它们的生存期长些。
</code></pre>
<p>同时还涉及到一个TCP 拥塞算法的问题，你可以用下面的命令查看本机提供的拥塞算法控制模块：</p>
<p>sysctlnet.ipv4.tcp_available_congestion_control</p>
<p>对于几种算法的分析，详情可以参考下：TCP拥塞控制算法的优缺点、适用环境、性能分析，比如高延时可以试用hybla，中等延时可以试用htcp算法等。</p>
<pre><code>如果想设置TCP 拥塞算法为hybla
net.ipv4.tcp_congestion_control=hybla

额外的，对于内核版高于于3.7.1的，我们可以开启tcp_fastopen：
net.ipv4.tcp_fastopen= 3
</code></pre>
<h4 id="io事件分配机制">IO事件分配机制</h4>
<p>在Linux启用高并发TCP连接，必须确认应用程序是否使用了合适的网络I/O技术和I/O事件分派机制。可用的I/O技术有同步I/O，非阻塞式同步I/O，以及异步I/O。在高TCP并发的情形下，如果使用同步I/O，这会严重阻塞程序的运转，除非为每个TCP连接的I/O创建一个线程。但是，过多的线程又会因系统对线程的调度造成巨大开销。因此，在高TCP并发的情形下使用同步I/O是不可取的，这时可以考虑使用非阻塞式同步I/O或异步I/O。非阻塞式同步I/O的技术包括使用select()，poll()，epoll等机制。异步I/O的技术就是使用AIO。</p>
<p>从I/O事件分派机制来看，使用select()是不合适的，因为它所支持的并发连接数有限(通常在1024个以内)。如果考虑性能，poll()也是不合适的，尽管它可以支持的较高的TCP并发数，但是由于其采用“轮询”机制，当并发数较高时，其运行效率相当低，并可能存在I/O事件分派不均，导致部分TCP连接上的I/O出现“饥饿”现象。而如果使用epoll或AIO，则没有上述问题(早期Linux内核的AIO技术实现是通过在内核中为每个I/O请求创建一个线程来实现的，这种实现机制在高并发TCP连接的情形下使用其实也有严重的性能问题。但在最新的Linux内核中，AIO的实现已经得到改进)。</p>
<p>综上所述，在开发支持高并发TCP连接的Linux应用程序时，应尽量使用epoll或AIO技术来实现并发的TCP连接上的I/O控制，这将为提升程序对高并发TCP连接的支持提供有效的I/O保证。</p>
<p>经过这样的优化配置之后，服务器的TCP并发处理能力会显著提高。以上配置仅供参考，用于生产环境请根据自己的实际情况调整观察再调整。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[常用算法速记-Python]]></title>
        <id>https://huyuwei1996.github.io/post/chang-yong-suan-fa-su-ji-python/</id>
        <link href="https://huyuwei1996.github.io/post/chang-yong-suan-fa-su-ji-python/">
        </link>
        <updated>2019-09-05T15:38:26.000Z</updated>
        <content type="html"><![CDATA[<h1 id="10-十大经典排序算法">1.0 十大经典排序算法</h1>
<figure data-type="image" tabindex="1"><img src="https://www.runoob.com/wp-content/uploads/2019/03/sort.png" alt="img" loading="lazy"></figure>
<figure data-type="image" tabindex="2"><img src="https://www.runoob.com/wp-content/uploads/2019/03/0B319B38-B70E-4118-B897-74EFA7E368F9.png" alt="img" loading="lazy"></figure>
<h1 id="11-冒泡排序">1.1 冒泡排序</h1>
<figure data-type="image" tabindex="3"><img src="https://www.runoob.com/wp-content/uploads/2019/03/bubbleSort.gif" alt="img" loading="lazy"></figure>
<pre><code class="language-python">def bubbleSort(arr):
    for i in range(1, len(arr)):
        for j in range(0, len(arr)-i):
            if arr[j] &gt; arr[j+1]:
                arr[j], arr[j + 1] = arr[j + 1], arr[j]
    return arr
</code></pre>
<h1 id="12-选择排序">1.2 选择排序</h1>
<figure data-type="image" tabindex="4"><img src="https://www.runoob.com/wp-content/uploads/2019/03/selectionSort.gif" alt="img" loading="lazy"></figure>
<pre><code class="language-python">def selectionSort(arr):
    for i in range(len(arr) - 1):
        # 记录最小数的索引
        minIndex = i
        for j in range(i + 1, len(arr)):
            if arr[j] &lt; arr[minIndex]:
                minIndex = j
        # i 不是最小数时，将 i 和最小数进行交换
        if i != minIndex:
            arr[i], arr[minIndex] = arr[minIndex], arr[i]
    return arr
</code></pre>
<h1 id="13-插入排序">1.3 插入排序</h1>
<figure data-type="image" tabindex="5"><img src="https://www.runoob.com/wp-content/uploads/2019/03/insertionSort.gif" alt="img" loading="lazy"></figure>
<pre><code class="language-python">def insertionSort(arr):
    for i in range(len(arr)):
        preIndex = i-1
        current = arr[i]
        while preIndex &gt;= 0 and arr[preIndex] &gt; current:
            arr[preIndex+1] = arr[preIndex]
            preIndex-=1
        arr[preIndex+1] = current
    return arr
</code></pre>
<h1 id="14-希尔排序">1.4 希尔排序</h1>
<figure data-type="image" tabindex="6"><img src="https://www.runoob.com/wp-content/uploads/2019/03/Sorting_shellsort_anim.gif" alt="img" loading="lazy"></figure>
<pre><code class="language-python">def shellSort(arr):
    import math
    gap=1
    while(gap &lt; len(arr)/3):
        gap = gap*3+1
    while gap &gt; 0:
        for i in range(gap,len(arr)):
            temp = arr[i]
            j = i-gap
            while j &gt;=0 and arr[j] &gt; temp:
                arr[j+gap]=arr[j]
                j-=gap
            arr[j+gap] = temp
        gap = math.floor(gap/3)
    return arr
</code></pre>
<h1 id="15-归并排序">1.5 归并排序</h1>
<figure data-type="image" tabindex="7"><img src="https://www.runoob.com/wp-content/uploads/2019/03/mergeSort.gif" alt="img" loading="lazy"></figure>
<pre><code class="language-python">def mergeSort(arr):
    import math
    if(len(arr)&lt;2):
        return arr
    middle = math.floor(len(arr)/2)
    left, right = arr[0:middle], arr[middle:]
    return merge(mergeSort(left), mergeSort(right))

def merge(left,right):
    result = []
    while left and right:
        if left[0] &lt;= right[0]:
            result.append(left.pop(0))
        else:
            result.append(right.pop(0));
    while left:
        result.append(left.pop(0))
    while right:
        result.append(right.pop(0));
    return result
</code></pre>
<h1 id="16-快速排序">1.6 快速排序</h1>
<figure data-type="image" tabindex="8"><img src="https://www.runoob.com/wp-content/uploads/2019/03/quickSort.gif" alt="img" loading="lazy"></figure>
<pre><code class="language-python">def quickSort(arr, left=None, right=None):
    left = 0 if not isinstance(left,(int, float)) else left
    right = len(arr)-1 if not isinstance(right,(int, float)) else right
    if left &lt; right:
        partitionIndex = partition(arr, left, right)
        quickSort(arr, left, partitionIndex-1)
        quickSort(arr, partitionIndex+1, right)
    return arr

def partition(arr, left, right):
    pivot = left
    index = pivot+1
    i = index
    while  i &lt;= right:
        if arr[i] &lt; arr[pivot]:
            swap(arr, i, index)
            index+=1
        i+=1
    swap(arr,pivot,index-1)
    return index-1

def swap(arr, i, j):
    arr[i], arr[j] = arr[j], arr[i]
</code></pre>
<h1 id="17-堆排序">1.7 堆排序</h1>
<figure data-type="image" tabindex="9"><img src="https://www.runoob.com/wp-content/uploads/2019/03/heapSort.gif" alt="img" loading="lazy"></figure>
<pre><code class="language-python">def buildMaxHeap(arr):
    import math
    for i in range(math.floor(len(arr)/2),-1,-1):
        heapify(arr,i)

def heapify(arr, i):
    left = 2*i+1
    right = 2*i+2
    largest = i
    if left &lt; arrLen and arr[left] &gt; arr[largest]:
        largest = left
    if right &lt; arrLen and arr[right] &gt; arr[largest]:
        largest = right

    if largest != i:
        swap(arr, i, largest)
        heapify(arr, largest)

def swap(arr, i, j):
    arr[i], arr[j] = arr[j], arr[i]

def heapSort(arr):
    global arrLen
    arrLen = len(arr)
    buildMaxHeap(arr)
    for i in range(len(arr)-1,0,-1):
        swap(arr,0,i)
        arrLen -=1
        heapify(arr, 0)
    return arr
</code></pre>
<h1 id="18-计数排序">1.8 计数排序</h1>
<figure data-type="image" tabindex="10"><img src="https://www.runoob.com/wp-content/uploads/2019/03/countingSort.gif" alt="img" loading="lazy"></figure>
<pre><code class="language-python">def countingSort(arr, maxValue):
    bucketLen = maxValue+1
    bucket = [0]*bucketLen
    sortedIndex =0
    arrLen = len(arr)
    for i in range(arrLen):
        if not bucket[arr[i]]:
            bucket[arr[i]]=0
        bucket[arr[i]]+=1
    for j in range(bucketLen):
        while bucket[j]&gt;0:
            arr[sortedIndex] = j
            sortedIndex+=1
            bucket[j]-=1
    return arr
</code></pre>
<h1 id="19-桶排序">1.9 桶排序</h1>
<figure data-type="image" tabindex="11"><img src="https://www.runoob.com/wp-content/uploads/2019/03/Bucket_sort_1.svg_.png" alt="img" loading="lazy"></figure>
<figure data-type="image" tabindex="12"><img src="https://www.runoob.com/wp-content/uploads/2019/03/Bucket_sort_2.svg_.png" alt="img" loading="lazy"></figure>
<h1 id="110-基数排序">1.10 基数排序</h1>
<figure data-type="image" tabindex="13"><img src="https://www.runoob.com/wp-content/uploads/2019/03/radixSort.gif" alt="img" loading="lazy"></figure>
<pre><code class="language-python">def radix(arr):
    
    digit = 0
    max_digit = 1
    max_value = max(arr)
    #找出列表中最大的位数
    while 10**max_digit &lt; max_value:
        max_digit = max_digit + 1
    
    while digit &lt; max_digit:
        temp = [[] for i in range(10)]
        for i in arr:
            #求出每一个元素的个、十、百位的值
            t = int((i/10**digit)%10)
            temp[t].append(i)
        
        coll = []
        for bucket in temp:
            for i in bucket:
                coll.append(i)
                
        arr = coll
        digit = digit + 1

    return arr
</code></pre>
]]></content>
    </entry>
</feed>