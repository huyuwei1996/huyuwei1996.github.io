<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://huyuwei1996.github.io/</id>
    <title>Huyuwei’s Blog</title>
    <updated>2019-09-05T15:58:58.912Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://huyuwei1996.github.io/"/>
    <link rel="self" href="https://huyuwei1996.github.io//atom.xml"/>
    <subtitle>学习使人进步</subtitle>
    <logo>https://huyuwei1996.github.io//images/avatar.png</logo>
    <icon>https://huyuwei1996.github.io//favicon.ico</icon>
    <rights>All rights reserved 2019, Huyuwei’s Blog</rights>
    <entry>
        <title type="html"><![CDATA[常用算法速记-Python]]></title>
        <id>https://huyuwei1996.github.io//post/chang-yong-suan-fa-su-ji-python</id>
        <link href="https://huyuwei1996.github.io//post/chang-yong-suan-fa-su-ji-python">
        </link>
        <updated>2019-09-05T15:38:26.000Z</updated>
        <content type="html"><![CDATA[<h1 id="10-十大经典排序算法">1.0 十大经典排序算法</h1>
<p><img src="https://www.runoob.com/wp-content/uploads/2019/03/sort.png" alt="img"></p>
<p><img src="https://www.runoob.com/wp-content/uploads/2019/03/0B319B38-B70E-4118-B897-74EFA7E368F9.png" alt="img"></p>
<h1 id="11-冒泡排序">1.1 冒泡排序</h1>
<p><img src="https://www.runoob.com/wp-content/uploads/2019/03/bubbleSort.gif" alt="img"></p>
<pre><code class="language-python">def bubbleSort(arr):
    for i in range(1, len(arr)):
        for j in range(0, len(arr)-i):
            if arr[j] &gt; arr[j+1]:
                arr[j], arr[j + 1] = arr[j + 1], arr[j]
    return arr
</code></pre>
<h1 id="12-选择排序">1.2 选择排序</h1>
<p><img src="https://www.runoob.com/wp-content/uploads/2019/03/selectionSort.gif" alt="img"></p>
<pre><code class="language-python">def selectionSort(arr):
    for i in range(len(arr) - 1):
        # 记录最小数的索引
        minIndex = i
        for j in range(i + 1, len(arr)):
            if arr[j] &lt; arr[minIndex]:
                minIndex = j
        # i 不是最小数时，将 i 和最小数进行交换
        if i != minIndex:
            arr[i], arr[minIndex] = arr[minIndex], arr[i]
    return arr
</code></pre>
<h1 id="13-插入排序">1.3 插入排序</h1>
<p><img src="https://www.runoob.com/wp-content/uploads/2019/03/insertionSort.gif" alt="img"></p>
<pre><code class="language-python">def insertionSort(arr):
    for i in range(len(arr)):
        preIndex = i-1
        current = arr[i]
        while preIndex &gt;= 0 and arr[preIndex] &gt; current:
            arr[preIndex+1] = arr[preIndex]
            preIndex-=1
        arr[preIndex+1] = current
    return arr
</code></pre>
<h1 id="14-希尔排序">1.4 希尔排序</h1>
<p><img src="https://www.runoob.com/wp-content/uploads/2019/03/Sorting_shellsort_anim.gif" alt="img"></p>
<pre><code class="language-python">def shellSort(arr):
    import math
    gap=1
    while(gap &lt; len(arr)/3):
        gap = gap*3+1
    while gap &gt; 0:
        for i in range(gap,len(arr)):
            temp = arr[i]
            j = i-gap
            while j &gt;=0 and arr[j] &gt; temp:
                arr[j+gap]=arr[j]
                j-=gap
            arr[j+gap] = temp
        gap = math.floor(gap/3)
    return arr
</code></pre>
<h1 id="15-归并排序">1.5 归并排序</h1>
<p><img src="https://www.runoob.com/wp-content/uploads/2019/03/mergeSort.gif" alt="img"></p>
<pre><code class="language-python">def mergeSort(arr):
    import math
    if(len(arr)&lt;2):
        return arr
    middle = math.floor(len(arr)/2)
    left, right = arr[0:middle], arr[middle:]
    return merge(mergeSort(left), mergeSort(right))

def merge(left,right):
    result = []
    while left and right:
        if left[0] &lt;= right[0]:
            result.append(left.pop(0))
        else:
            result.append(right.pop(0));
    while left:
        result.append(left.pop(0))
    while right:
        result.append(right.pop(0));
    return result
</code></pre>
<h1 id="16-快速排序">1.6 快速排序</h1>
<p><img src="https://www.runoob.com/wp-content/uploads/2019/03/quickSort.gif" alt="img"></p>
<pre><code class="language-python">def quickSort(arr, left=None, right=None):
    left = 0 if not isinstance(left,(int, float)) else left
    right = len(arr)-1 if not isinstance(right,(int, float)) else right
    if left &lt; right:
        partitionIndex = partition(arr, left, right)
        quickSort(arr, left, partitionIndex-1)
        quickSort(arr, partitionIndex+1, right)
    return arr

def partition(arr, left, right):
    pivot = left
    index = pivot+1
    i = index
    while  i &lt;= right:
        if arr[i] &lt; arr[pivot]:
            swap(arr, i, index)
            index+=1
        i+=1
    swap(arr,pivot,index-1)
    return index-1

def swap(arr, i, j):
    arr[i], arr[j] = arr[j], arr[i]
</code></pre>
<h1 id="17-堆排序">1.7 堆排序</h1>
<p><img src="https://www.runoob.com/wp-content/uploads/2019/03/heapSort.gif" alt="img"></p>
<pre><code class="language-python">def buildMaxHeap(arr):
    import math
    for i in range(math.floor(len(arr)/2),-1,-1):
        heapify(arr,i)

def heapify(arr, i):
    left = 2*i+1
    right = 2*i+2
    largest = i
    if left &lt; arrLen and arr[left] &gt; arr[largest]:
        largest = left
    if right &lt; arrLen and arr[right] &gt; arr[largest]:
        largest = right

    if largest != i:
        swap(arr, i, largest)
        heapify(arr, largest)

def swap(arr, i, j):
    arr[i], arr[j] = arr[j], arr[i]

def heapSort(arr):
    global arrLen
    arrLen = len(arr)
    buildMaxHeap(arr)
    for i in range(len(arr)-1,0,-1):
        swap(arr,0,i)
        arrLen -=1
        heapify(arr, 0)
    return arr
</code></pre>
<h1 id="18-计数排序">1.8 计数排序</h1>
<p><img src="https://www.runoob.com/wp-content/uploads/2019/03/countingSort.gif" alt="img"></p>
<pre><code class="language-python">def countingSort(arr, maxValue):
    bucketLen = maxValue+1
    bucket = [0]*bucketLen
    sortedIndex =0
    arrLen = len(arr)
    for i in range(arrLen):
        if not bucket[arr[i]]:
            bucket[arr[i]]=0
        bucket[arr[i]]+=1
    for j in range(bucketLen):
        while bucket[j]&gt;0:
            arr[sortedIndex] = j
            sortedIndex+=1
            bucket[j]-=1
    return arr
</code></pre>
<h1 id="19-桶排序">1.9 桶排序</h1>
<p><img src="https://www.runoob.com/wp-content/uploads/2019/03/Bucket_sort_1.svg_.png" alt="img"></p>
<p><img src="https://www.runoob.com/wp-content/uploads/2019/03/Bucket_sort_2.svg_.png" alt="img"></p>
<h1 id="110-基数排序">1.10 基数排序</h1>
<p><img src="https://www.runoob.com/wp-content/uploads/2019/03/radixSort.gif" alt="img"></p>
<pre><code class="language-python">def radix(arr):
    
    digit = 0
    max_digit = 1
    max_value = max(arr)
    #找出列表中最大的位数
    while 10**max_digit &lt; max_value:
        max_digit = max_digit + 1
    
    while digit &lt; max_digit:
        temp = [[] for i in range(10)]
        for i in arr:
            #求出每一个元素的个、十、百位的值
            t = int((i/10**digit)%10)
            temp[t].append(i)
        
        coll = []
        for bucket in temp:
            for i in bucket:
                coll.append(i)
                
        arr = coll
        digit = digit + 1

    return arr
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[理财小白营]]></title>
        <id>https://huyuwei1996.github.io//post/li-cai-xiao-bai-ying</id>
        <link href="https://huyuwei1996.github.io//post/li-cai-xiao-bai-ying">
        </link>
        <updated>2019-09-01T15:42:51.000Z</updated>
        <content type="html"><![CDATA[<p>微信上报了个9元的课程，周末抽空补了下进度，还是尽快去补完进度，每天坚持了解一些。</p>
<h2 id="入门阅读">入门阅读</h2>
<h3 id="1小狗钱钱"><a href="https://docs.qq.com/doc/DWExvQ2ZmUGhxcmVw">1.《小狗钱钱》</a></h3>
<ul>
<li><a href="https://mp.weixin.qq.com/s/N-Al5hsUVihX0ehOy99_Hg">1.1 想变的有钱，这3个建议可以帮你</a>
<ul>
<li>1.1.1 缺钱的时候，钱就格外重要</li>
<li>1.1.2 不想一辈子就穷下去，现在就要学会理财</li>
<li>1.1.3 人的精力有限，删除干扰选项，才更有机会实现愿望</li>
<li>1.1.4 永远不要试试看，只有“做”或“不做”</li>
<li>总结
<ul>
<li>写下Top3愿望</li>
<li>制作梦想相册——激励和推动自己</li>
<li>准备梦想储蓄罐</li>
</ul>
</li>
</ul>
</li>
<li><a href="https://mp.weixin.qq.com/s/GHm4FIm82t0955xXDeK8TQ">1.2 赚钱没你想的那么难</a>
<ul>
<li>1.2.1 写“成功日记”
<ul>
<li>任何小事都可以，给自己加油、自信</li>
</ul>
</li>
<li>1.2.2 商人赚钱建议
<ul>
<li>为别人解决问题</li>
<li>把精力放在你知道的事情和能够做的事情上</li>
</ul>
</li>
<li>1.2.3 觉得钱难赚的人
<ul>
<li>没有认真思考
<ul>
<li>赚钱你要花费多少时间？</li>
</ul>
</li>
<li>不愿面对困难
<ul>
<li>找借口，放弃</li>
</ul>
</li>
</ul>
</li>
<li>总结
<ul>
<li>写“成功日记”，增加自信</li>
<li>别人需要什么？</li>
<li>我能做什么？</li>
</ul>
</li>
</ul>
</li>
<li><a href="https://mp.weixin.qq.com/s/BQ0AjU7epTCusNvL8k7Uog">1.3 99%的人不成功，都是因为它</a>
<ul>
<li>1.3.1 遇到困难的时候，越要坚持自己的想法</li>
<li>1.3.2 要每天不间断地去做对你未来意义重大的事
<ul>
<li>21天理论——坚持21天就会变成习惯</li>
</ul>
</li>
<li>1.3.3 当决定做一件事的时候，就要立即去做
<ul>
<li>否则很可能永远不会再去做</li>
</ul>
</li>
<li>总结
<ul>
<li>坚持最重要</li>
</ul>
</li>
</ul>
</li>
<li><a href="https://mp.weixin.qq.com/s/GFq6v8ZpD2-CP_YEqRT6IQ">1.4 不要杀死你的鹅</a>
<ul>
<li>1.4.1 不要杀死你的鹅
<ul>
<li>不要花光本金，否则永远不会有收益</li>
</ul>
</li>
<li>总结
<ul>
<li>负债的人应该扔掉所有信用卡
<ul>
<li>使用信用卡，总比使用现金花的多</li>
</ul>
</li>
<li>尽可能少的偿还贷款
<ul>
<li>如果是信用卡债还是建议先还债</li>
<li>还要考虑通货膨胀，以后钱会缩水</li>
</ul>
</li>
<li>对于消费贷款，应该将不用于生活的钱存起来一半，另一半用于还债
<ul>
<li>存钱，保证储蓄(本金)</li>
</ul>
</li>
<li>把想要的东西分为“必要、需要、想要”
<ul>
<li>控制消费</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="https://mp.weixin.qq.com/s/ICJtLRYf5UYkTpBjgOY8TA">1.5 投资，遵循这3个原则就足够了</a>
<ul>
<li>1.5.1 现金的重要性，应对突发情况
<ul>
<li>投资前，做好资产配置</li>
</ul>
</li>
<li>1.5.2 金钱能否带来幸福，取决于是否懂得怎样使用它</li>
<li>1.5.3 穷人思维
<ul>
<li>拿到钱买买买，吃喝玩乐，奢侈享受，忽略了投资</li>
</ul>
</li>
<li>1.5.4 富人思维
<ul>
<li>消费一些钱作为奖励，将80%甚至更多的钱投资，继续赚取更多的钱</li>
</ul>
</li>
<li>总结
<ul>
<li>投资要安全
<ul>
<li>本金不能丧失</li>
</ul>
</li>
<li>要有收益
<ul>
<li>先评估风险，再考虑收益多少</li>
</ul>
</li>
<li>充分了解投资对象
<ul>
<li>“不懂的就不要碰”</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="2晚间分享财富的载体时间量化思维"><a href="https://shimo.im/docs/660f6eab67a74f47/read">2.【晚间分享】财富的载体——时间&amp;量化思维</a></h3>
<ul>
<li>2.1 大多数人在工作和生活中，更多地注意金钱，而很少注意“时间”
<ul>
<li>有钱人会感觉时间比金钱重要，愿意用钱买时间</li>
<li>没钱的人更在乎钱，不在乎时间，愿意用时间做一些没什么价值的事情</li>
</ul>
</li>
<li>2.2 穷人思维
<ul>
<li>因为没钱，所以缓缓；等有钱了，怎样怎样</li>
<li>为免费、特价等，付出过多的资源和时间
<ul>
<li>可能浪费过多的时间和注意力</li>
</ul>
</li>
</ul>
</li>
<li>2.3 理财思维
<ul>
<li>重视时间成本</li>
</ul>
</li>
<li>2.4 不理财不等于没风险，通货膨胀其实就是最大的风险</li>
<li>2.5 “怕吃苦，吃苦一辈子，不怕苦，吃苦一阵子”</li>
<li>总结
<ul>
<li>每个人的时间都有一定的金钱价值
<ul>
<li>用凡事不要凭感觉，用量化思维计算，选择更有价值的事做</li>
</ul>
</li>
<li>金钱是有时间价值的，现在的钱比未来更值钱
<ul>
<li>提高投资能力，让钱更值钱</li>
</ul>
</li>
<li>学习是有时间成本的
<ul>
<li>学的越晚，消耗越大</li>
</ul>
</li>
</ul>
</li>
<li>拓展知识
<ul>
<li>投资的不可能三角
<ul>
<li>投资理财目标中，收益性、安全性、流动性三者，最多只能占两个
<ul>
<li>收益性、安全性、！流动性
<ul>
<li>房子</li>
</ul>
</li>
<li>安全性、流动性、！收益性
<ul>
<li>活期存款、货币基金等</li>
</ul>
</li>
<li>收益性、流动性、！安全性
<ul>
<li>部分P2P</li>
</ul>
</li>
</ul>
</li>
<li>通过投资资产的三种属性，判断投资品种是否靠谱</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="3晨读美文两种思维方式决定了你只能当穷人"><a href="https://docs.qq.com/doc/DR3ZjZHBVdk5adVBa">3.【晨读美文】两种思维方式决定了你只能当穷人</a></h3>
<h3 id="4午间茶馆小狗钱钱拆读"><a href="https://docs.qq.com/doc/DR2dRWldBR0ZQVGNp">4.【午间茶馆】《小狗钱钱》拆读</a></h3>
<h3 id="5晚间分享玩转信用卡"><a href="https://docs.qq.com/doc/DR25ZdVZkVFhRSnR1">5.【晚间分享】玩转信用卡</a></h3>
<h3 id="6晨读美文-要为你的未来花点钱"><a href="https://docs.qq.com/doc/DWGRkcEx0YWFBVGlO">6.【晨读美文】-要为你的未来花点钱</a></h3>
<p><em>XMind: ZEN - Trial Version</em><br>
<img src="https://huyuwei1996.github.io//post-images/1567352666078.png" alt=""></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[数据结构与算法-Python]]></title>
        <id>https://huyuwei1996.github.io//post/suan-fa-xue-xi-python</id>
        <link href="https://huyuwei1996.github.io//post/suan-fa-xue-xi-python">
        </link>
        <updated>2019-08-31T13:21:20.000Z</updated>
        <content type="html"><![CDATA[<h2 id="算法的五大特性">算法的五大特性</h2>
<ol>
<li>
<p><strong>输入</strong>：算法具有0个或者多个输入</p>
</li>
<li>
<p><strong>输出</strong>：算法至少有1个或者多个输出</p>
</li>
<li>
<p><strong>有穷性</strong>：算法在有限的步骤之后会自动结束而不会无线循环，并且，每一个步骤在一个可接受的时间内完成</p>
</li>
<li>
<p><strong>确定性</strong>：算法中的每一步都有确定的定义，不会出现二义性</p>
</li>
<li>
<p><strong>可行性</strong>：算法的每一步都是可行的，也就是说每一步都能够执行有限次数的完成</p>
</li>
</ol>
<h2 id="时间复杂度与大o表示法">时间复杂度与大O表示法</h2>
<ul>
<li><strong>最优时间复杂度</strong></li>
<li><strong>最坏时间复杂度</strong></li>
<li><strong>平均时间复杂度</strong></li>
</ul>
<p>主要关注算法的最坏情况，即<strong>最坏时间复杂度</strong></p>
<h3 id="时间复杂度的几条计算基本规则">时间复杂度的几条计算基本规则</h3>
<ol>
<li>
<p>基本操作，即只有常数项，认为其时间复杂度为<strong>O(1)</strong></p>
</li>
<li>
<p>顺序结构，时间复杂度按<strong>加法</strong>进行计算</p>
</li>
<li>
<p>循环结构，时间复杂度按<strong>乘法</strong>进行计算</p>
</li>
<li>
<p>分支结构，时间复杂度<strong>取最大值</strong></p>
</li>
<li>
<p>判断一个算法的效率时，往往只需要关注操作数量的<strong>最高项</strong>，其次要项和常数项可以忽略</p>
</li>
<li>
<p>在没有特殊说明时，我们所分析的算法的时间复杂度都是指<strong>最坏时间复杂度</strong></p>
</li>
</ol>
<h2 id="常见时间复杂度">常见时间复杂度</h2>
<h3 id="常见时间复杂度直接的关系">常见时间复杂度直接的关系</h3>
<p><strong>O(1) &lt; O(logn) &lt; O(n) &lt; O(nlogn) &lt; O(n<sup>2</sup>) &lt; O(n<sup>2</sup>logn) &lt; O(n<sup>3</sup>) &lt; O(2<sup>n</sup>) &lt; O(n!) &lt; O(n<sup>n</sup>)</strong></p>
<h2 id="python内置类型性能分析">Python内置类型性能分析</h2>
<h3 id="timeit模块">timeit模块</h3>
<p><strong>class timeit.Timer(stmt='pass', setup='pass', timer=&lt;timer function&gt;)</strong></p>
<p><strong>timeit.Timer.timeit(number=1000000)</strong></p>
<p>测试代码时的测试次数，默认为1000000次</p>
<h3 id="list内置操作的时间复杂度">list内置操作的时间复杂度</h3>
<h3 id="dict内置操作的时间复杂度">dict内置操作的时间复杂度</h3>
<h2 id="数据结构">数据结构</h2>
<h3 id="概念">概念</h3>
<h3 id="算法与数据结构的区别">算法与数据结构的区别</h3>
<p>程序 = 算法 + 数据结构</p>
<h3 id="抽象数据类型abstract-data-type-简称adt">抽象数据类型(Abstract Data Type 简称ADT)</h3>
<h2 id="顺序表的结构和实现">顺序表的结构和实现</h2>
<h3 id="顺序表的结构">顺序表的结构</h3>
<h3 id="顺序表的两种基本实现方式">顺序表的两种基本实现方式</h3>
<ul>
<li>一体式结构</li>
<li>分离式结构</li>
</ul>
<h3 id="元素存储区替换">元素存储区替换</h3>
<h3 id="元素存储区扩充">元素存储区扩充</h3>
<h4 id="扩充的两种策略">扩充的两种策略</h4>
<p>第二种=用空间换时间</p>
<h2 id="顺序表的操作">顺序表的操作</h2>
<h3 id="增加元素">增加元素</h3>
<h3 id="删除元素">删除元素</h3>
<h2 id="python中的顺序表">Python中的顺序表</h2>
<p>Python中的list和tuple两种类型采用了顺序表的实现技术</p>
<h3 id="list的基本实现技术">list的基本实现技术</h3>
<h2 id="链表">链表</h2>
<h3 id="单向链表">单向链表</h3>
<h4 id="操作">操作</h4>
<h4 id="实现">实现</h4>
<pre><code class="language-python">class Node(object):
    &quot;&quot;&quot;节点&quot;&quot;&quot;

    def __init__(self, item):
        self.item = item
        self.next = None


class SingleLinkList(object):
    &quot;&quot;&quot;单链表&quot;&quot;&quot;

    def __init__(self, node=None):
        self.__head = node  # 私有属性

    def is_empty(self):
        &quot;&quot;&quot;链表是否为空&quot;&quot;&quot;
        return self.__head is None

    def length(self):
        &quot;&quot;&quot;链表长度&quot;&quot;&quot;
        # cursor游标，用来移动，遍历节点
        cur = self.__head
        # count计数
        count = 0
        while cur is not None:
            count += 1
            cur = cur.next
        return count

    def travel(self):
        &quot;&quot;&quot;遍历整个链表&quot;&quot;&quot;
        # cursor游标，用来移动，遍历节点
        cur = self.__head
        while cur is not None:
            print(cur.item, end=&quot; &quot;)
            cur = cur.next
        print(&quot;&quot;)

    def add(self, item):
        &quot;&quot;&quot;链表头部添加元素，头插法&quot;&quot;&quot;
        node = Node(item)
        if self.is_empty():
            self.__head = node
        else:
            node.next = self.__head
            self.__head = node

    def append(self, item):
        &quot;&quot;&quot;链表尾部添加元素，尾插法&quot;&quot;&quot;
        node = Node(item)
        if self.is_empty():
            self.__head = node
        else:
            cur = self.__head
            while cur.next is not None:
                cur = cur.next
            cur.next = node

    def insert(self, pos, item):
        &quot;&quot;&quot;指定位置添加元素
        :param pos 位置
        &quot;&quot;&quot;
        if pos &lt;= 0:
            self.add(item)
        elif pos &gt; (self.length() - 1):
            self.append(item)
        else:
            # pre
            pre = self.__head
            count = 0
            while count &lt; (pos - 1):
                count += 1
                pre = pre.next
            # 退出循环后。pre指向pos-1位置
            node = Node(item)
            node.next = pre.next
            pre.next = node

    def remove(self, item):
        &quot;&quot;&quot;删除节点&quot;&quot;&quot;
        cur = self.__head
        pre = None
        while cur is not None:
            if cur.item == item:
                # 先判断此节点是否头节点
                if cur == self.__head:
                    self.__head = cur.next
                else:
                    pre.next = cur.next
                break
            else:
                pre = cur
                cur = cur.next

    def search(self, item):
        &quot;&quot;&quot;查找节点是否存在&quot;&quot;&quot;
        cur = self.__head
        while cur is not None:
            if cur.item == item:
                return True
            else:
                cur = cur.next
        return False


if __name__ == '__main__':
    n = Node(100)
    sll = SingleLinkList()
    print('链表是否为空', sll.is_empty())
    print('链表长度', sll.length())
    sll.append(1)
    sll.append(2)
    sll.append(3)
    sll.add(4)
    sll.insert(0, 5)
    sll.insert(5, 10)
    sll.insert(2, 7)
    print('链表是否为空', sll.is_empty())
    print('链表长度', sll.length())
    sll.travel()
    print('查找节点是否存在', sll.search(1))
    sll.remove(5)
    sll.travel()
    sll.remove(10)
    sll.travel()
    sll.remove(2)
    sll.travel()

</code></pre>
<h4 id="链表与顺序表对比">链表与顺序表对比</h4>
<h3 id="双向链表">双向链表</h3>
<h4 id="操作-2">操作</h4>
<h4 id="实现-2">实现</h4>
<pre><code class="language-python">class DoubleNode(object):
    &quot;&quot;&quot;节点&quot;&quot;&quot;

    def __init__(self, item):
        self.item = item
        self.next = None
        self.prev = None


class DoubleLinkList(object):
    &quot;&quot;&quot;双向链表&quot;&quot;&quot;

    def __init__(self, node=None):
        self.__head = node  # 私有属性

    def is_empty(self):
        &quot;&quot;&quot;链表是否为空&quot;&quot;&quot;
        return self.__head is None

    def length(self):
        &quot;&quot;&quot;链表长度&quot;&quot;&quot;
        # cursor游标，用来移动，遍历节点
        cur = self.__head
        # count计数
        count = 0
        while cur is not None:
            count += 1
            cur = cur.next
        return count

    def travel(self):
        &quot;&quot;&quot;遍历整个链表&quot;&quot;&quot;
        # cursor游标，用来移动，遍历节点
        cur = self.__head
        while cur is not None:
            print(cur.item, end=&quot; &quot;)
            cur = cur.next
        print(&quot;&quot;)

    def add(self, item):
        &quot;&quot;&quot;链表头部添加元素，头插法&quot;&quot;&quot;
        node = DoubleNode(item)
        # # function 1
        # node.next = self.__head
        # self.__head = node
        # node.next.prev = node

        # function 2
        node.next = self.__head
        self.__head.prev = node
        self.__head = node

    def append(self, item):
        &quot;&quot;&quot;链表尾部添加元素，尾插法&quot;&quot;&quot;
        node = DoubleNode(item)
        if self.is_empty():
            self.__head = node
        else:
            cur = self.__head
            while cur.next is not None:
                cur = cur.next
            cur.next = node
            node.prev = cur

    def insert(self, pos, item):
        &quot;&quot;&quot;指定位置添加元素
        :param pos 位置
        &quot;&quot;&quot;
        if pos &lt;= 0:
            self.add(item)
        elif pos &gt; (self.length() - 1):
            self.append(item)
        else:
            cur = self.__head
            count = 0

            while count &lt; pos:
                count += 1
                cur = cur.next
            node = DoubleNode(item)
            node.next = cur
            node.prev = cur.prev
            # function 1
            cur.prev.next = node
            cur.prev = node

            # # function 2
            # cur.prev = node
            # cur.prev.next = node

    def remove(self, item):
        &quot;&quot;&quot;删除节点&quot;&quot;&quot;
        cur = self.__head
        while cur is not None:
            if cur.item == item:
                # 判断是否头节点
                if cur == self.__head:
                    self.__head = cur.next
                    if cur.next:
                        # 判断链表是否只有一个节点
                        cur.next.prev = None
                else:
                    cur.prev.next = cur.next
                    if cur.next:
                        cur.next.prev = cur.prev
                break
            else:
                cur = cur.next

    def search(self, item):
        &quot;&quot;&quot;查找节点是否存在&quot;&quot;&quot;
        cur = self.__head
        while cur is not None:
            if cur.item == item:
                return True
            else:
                cur = cur.next
        return False


if __name__ == '__main__':
    n = DoubleNode(100)
    dll = DoubleLinkList()
    print('链表是否为空', dll.is_empty())
    print('链表长度', dll.length())
    dll.append(1)
    dll.append(2)
    dll.append(3)
    dll.add(4)
    dll.insert(0, 5)
    dll.insert(5, 10)
    dll.insert(2, 7)
    print('链表是否为空', dll.is_empty())
    print('链表长度', dll.length())
    dll.travel()
    dll.remove(2)
    dll.travel()
    dll.remove(5)
    dll.travel()
    dll.remove(10)
    dll.travel()
    print('查找节点是否存在', dll.search(1))

</code></pre>
<h3 id="单项循环链表">单项循环链表</h3>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[ Locust & Jmeter 对比]]></title>
        <id>https://huyuwei1996.github.io//post/locust-and-jmeter-dui-bi</id>
        <link href="https://huyuwei1996.github.io//post/locust-and-jmeter-dui-bi">
        </link>
        <updated>2019-08-30T15:52:39.000Z</updated>
        <summary type="html"><![CDATA[<blockquote>
<p>转自——Locust 源码阅读及特点思考 (三)：<a href="https://testerhome.com/topics/11853">https://testerhome.com/topics/11853</a></p>
</blockquote>
]]></summary>
        <content type="html"><![CDATA[<blockquote>
<p>转自——Locust 源码阅读及特点思考 (三)：<a href="https://testerhome.com/topics/11853">https://testerhome.com/topics/11853</a></p>
</blockquote>
<!-- more -->
<p>github：<a href="https://github.com/locustio/locust">https://github.com/locustio/locust</a></p>
<h2 id="性能测试工具一般如何实现">性能测试工具一般如何实现</h2>
<h3 id="1用例生成">1.用例生成</h3>
<p>一般两种方式，手写脚本和录制用例。<br>
脚本可以是各种格式各种形式的，比如HttpRunner的YAML，Jmeter的jmx/xml，或者Locust的python代码。<br>
录制用例一般使用抓包工具或者自己内含抓包实现（Pcap4j），抓取网络包（TCP/UDP）再自己解析包内容使其成为可以识别的形式。<br>
用例录制后如果要保存，要保存成指定脚本的样式，这样才能在工具中复用。</p>
<p>用例最好是支持多种协议的，其中Http(s)协议，TCP协议最常用。</p>
<h3 id="2用例回放">2.用例回放</h3>
<p>如果回放一次，可以说是接口测试。<br>
如果回放N次，可以说是性能测试。<br>
这时需要配置一些性能测试指标如用户数、步长、思考时间等，不多解释。<br>
总体是将一个压力请求复制N份，然后在指定时间（步长）内，将这些请求发出去。<br>
Java的复制，可以是创建多个线程实现。<br>
Locust的复制，是复制多个用例，放到数组里，然后再弹出去（请求）。</p>
<h3 id="3结果实时显示">3.结果实时显示</h3>
<p>使用绘图工具实现。<br>
一般是一段时间（1秒或者几百毫秒）间隔的用例回放的某个返回数据的平均值，将其在图上打点，然后之前的点再和这个点连起来。<br>
这个工作一般都是开源的绘图工具实现的。<br>
Locust的实现是前端的，在 chart.js 中，LocustLineChart，还是比较简陋的。<br>
Jmeter的可以安装插件显示，也简陋。</p>
<p>除此之外，还需要实时显示错误日志。</p>
<h3 id="4压力机和服务端性能指标监控">4.压力机和服务端性能指标监控</h3>
<p>方式很多，可以是shell脚本监控，专门的监控软件监控，自己实现的程序监控。<br>
可以是在被压测的服务器端运行客户端程序，将指定的监控指标传给master节点，绘图。<br>
或者直接zabbix等专业的监控。<br>
服务器端的性能监控还会包含更多，如pinpoint，CAT等等较专业的。<br>
Jmeter也是安装插件实现，简陋。<br>
Locust就没有。</p>
<h3 id="5测试报告生成">5.测试报告生成</h3>
<p>用例回放的结果，会保存起来，可以保存在内存，文件，NoSQL，数据库中。<br>
文件可以是csv格式。<br>
NoSQL可以是Redis，Mongodb等<br>
数据库就太多了，常用是InfluxDB，MySQL。<br>
然后生成报告时，将这些数据读出来，绘图，加工，成为报告。<br>
Locust也没有这部分功能。<br>
Jmeter3.0开始支持报告生成，但是有硬伤。</p>
<h2 id="从上述实现看locust和jmeter">从上述实现看Locust和Jmeter</h2>
<h3 id="1用例生成-2">1.用例生成</h3>
<p>python脚本是亮点，毕竟代码可以实现一切需求。<br>
但不足之处很明显：<br>
1.util包没有，复杂用例编写代码工作量很大，维护成本很大，同时考验代码功力。<br>
2.没有录制用例，保存用例功能，即便使用HttpRunner支持的录制保存，也只是基础用例。<br>
实际上性能测试刚需的如参数化，还是要手写python脚本。<br>
以上对于时间较紧的测试需求，用Locust明显是撞墙。</p>
<p>Jmeter明显好很多，本身GUI界面简单明了，各种内置函数帮助你写脚本。<br>
就算用例编写很复杂，还提供了beanshell，可以使用Java代码实现（虽然调试比较费劲）。<br>
同时Jmeter拥有各种协议的插件，还是不错的。</p>
<h3 id="2用例回放-2">2.用例回放</h3>
<p>Locust存在硬伤，因为是python+协程实现，性能很弱。<br>
我自测过，4个逻辑核的联想笔记本，Locust使用4个slave，造成的压力是1.3k，Jmeter是13k，差了10倍。</p>
<h3 id="3结果实时显示-2">3.结果实时显示</h3>
<p>Locust比Jmeter更亲切一点，半斤八两。<br>
解释一下为什么说半斤八两。<br>
简单几百几千个请求的情况就不说了，性能测试对压测时间压测的量是有要求的，百万上亿的请求不是事儿。<br>
这时候对压测图形的要求就比较高了，最理想的是可以看到每个细节，不能秘密麻麻的看都看不清，那无法定位问题。</p>
<h3 id="4压力机和服务端性能指标监控-2">4.压力机和服务端性能指标监控</h3>
<p>Locust压根没有，Jmeter是有但是和没有差不多。<br>
这个没什么，服务器的性能监控越来越复杂，不好监控。<br>
LoadRunner的服务器性能指标监控是非常棒的，确实专业。</p>
<h3 id="5测试报告生成-2">5.测试报告生成</h3>
<p>Locust压根没有，Jmeter3.0开始有，并且还可以接受。<br>
Jmeter报告的硬伤：报告来源于分析日志，日志格式是csv的，平均10000个请求占用1MB的空间。<br>
如果请求数上千万，日志就非常大了，生成报告可以卡死。</p>
<p>测试报告非常重要：<br>
1.有的产品是必须要测试报告的，Locust直接PASS。<br>
2.没测试报告文件，很难回复测试结果，不够直观也很容易解释不清楚。</p>
<p>理想的测试报告是最好有结论的，领导最喜欢的就是直观，一句话告诉我性能行不行。<br>
如果有性能截图的话，领导的问题往往非常直接，比如：这里怎么下去了，这里怎么上去了等等，非常便于讨论问题。<br>
如果都是乱糟糟的文字描述，太费劲。</p>
<h2 id="从实现评价locust">从实现评价Locust</h2>
<p>能用，但不实用。</p>
<h2 id="工作中典型场景看locust">工作中典型场景看Locust</h2>
<h3 id="领导测一下这个httpget接口顺便做一下性能测试压力不用太大">领导：测一下这个http/get接口，顺便做一下性能测试，压力不用太大。</h3>
<p>Locust：先用postman测试基本功能，后写python脚本压测，参数化实现工作量较大，如果领导突然说压力要大一点儿，Locust就不行了。<br>
Jmeter：全部使用Jmeter测试，根本不用担心压力多大，接口测试的简单边界Jmeter也能胜任。</p>
<h3 id="领导测一下这个页面性能看看能支撑多少用户rps-访问">领导：测一下这个页面性能，看看能支撑多少用户/RPS 访问。</h3>
<p>Locust：基本抓瞎。</p>
<ol>
<li>使用 fiddler/charles 看页面请求，过滤掉静态资源，为每一个请求写脚本（HttpRunner的录制生成）。</li>
<li>如果有服务器状态标识如session/token，或者postman额外请求，或者chrome开发者工具找到对应内容，手工保存。</li>
<li>最好没有参数化部分，要不然脚本改动很大。</li>
<li>请求太多可能会造成压力分配有限，Locust可能不能胜任。</li>
<li>如果领导需要加上静态资源，生成脚本动作重新来一遍。</li>
</ol>
<p>Jmeter：</p>
<ol>
<li>自身录制请求，软件内过滤静态资源较方便，每个请求都会录制好，手动操作很少。</li>
<li>不用额外postman，Jmeter自身就胜任各种请求，同时sesson内容（id）或者token直接使用参数化保存在Jmeter内部，少去手工保存动作。</li>
<li>无所谓参数化，很简单。</li>
<li>压力足够。</li>
<li>如果要加静态资源，亮化静态请求即可。 同时，加http头信息非常方便。</li>
</ol>
<h3 id="领导测试报告导出来看一下">领导：测试报告导出来看一下。</h3>
<p>Locust：what？<br>
Jmeter：稍等，马上。</p>
<h3 id="领导增加并发并发不够看不出问题">领导：增加并发，并发不够看不出问题。</h3>
<p>Locust：给我几台虚拟机<br>
Jmeter：哦，好的。</p>
<h2 id="locust的优势">Locust的优势</h2>
<p>要改造成Jmeter的程度几乎是不可能的，Jmeter多少人在维护多少人在用，Locust几个人维护几个人在用，几乎是无底洞。</p>
<ul>
<li>非Java语言说出去好听，</li>
<li>语言特性，工作不需要Jmeter那么多的话，开发起来会比较快。</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[SQL学习]]></title>
        <id>https://huyuwei1996.github.io//post/sql-xue-xi</id>
        <link href="https://huyuwei1996.github.io//post/sql-xue-xi">
        </link>
        <updated>2019-08-30T13:38:25.000Z</updated>
        <summary type="html"><![CDATA[<h3 id="mysql80客户端连接报错">mysql8.0客户端连接报错</h3>
<p>原因: caching_sha2_password, 是mysql8.0的一个新特性, 默认使用该身份认证插件进行加密. 但是一些客户端, 诸如sequel pro, Navicat 不支持这种插件, 这个时候就会出现如上错误.</p>
]]></summary>
        <content type="html"><![CDATA[<h3 id="mysql80客户端连接报错">mysql8.0客户端连接报错</h3>
<p>原因: caching_sha2_password, 是mysql8.0的一个新特性, 默认使用该身份认证插件进行加密. 但是一些客户端, 诸如sequel pro, Navicat 不支持这种插件, 这个时候就会出现如上错误.</p>
<!-- more -->
<blockquote>
<p>在终端登录mysql -uroot -p账户密码</p>
</blockquote>
<pre><code class="language-sql">#修改加密规则 
mysql&gt; ALTER USER 'root'@'localhost' IDENTIFIED BY 'password' PASSWORD EXPIRE NEVER;
Query OK, 0 rows affected (0.00 sec)
#更新用户密码
mysql&gt;  ALTER USER 'root'@'localhost' IDENTIFIED WITH mysql_native_password BY 'password';
Query OK, 0 rows affected (0.00 sec)
#刷新权限
mysql&gt; FLUSH PRIVILEGES;
Query OK, 0 rows affected (0.00 sec)
#修改用户密码
mysql&gt; alter user 'root'@'localhost' identified by '要设置的账户密码';
Query OK, 0 rows affected (0.00 sec)
</code></pre>
<h3 id="测试版sequelpro地址">测试版sequelpro地址</h3>
<p><a href="https://sequelpro.com/test-builds">https://sequelpro.com/test-builds</a></p>
<h3 id="mac平台">mac平台：</h3>
<p>Sequel Pro</p>
<h3 id="其他平台">其他平台：</h3>
<p>MySQL Workbench</p>
<h3 id="学习sql练习网站">学习sql练习网站</h3>
<p><a href="https://sqlbolt.com">https://sqlbolt.com</a></p>
<p>todo：Exercise 6</p>
]]></content>
    </entry>
</feed>