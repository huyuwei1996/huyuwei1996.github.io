<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://huyuwei1996.github.io/</id>
    <title>Huyuwei的个人博客</title>
    <updated>2020-04-13T07:40:51.231Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://huyuwei1996.github.io/"/>
    <link rel="self" href="https://huyuwei1996.github.io/atom.xml"/>
    <subtitle>逆水行舟，不进则退</subtitle>
    <logo>https://huyuwei1996.github.io/images/avatar.png</logo>
    <icon>https://huyuwei1996.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, Huyuwei的个人博客</rights>
    <entry>
        <title type="html"><![CDATA[JPype1 - python2.7下mac和win安装解决]]></title>
        <id>https://huyuwei1996.github.io/post/jpype1-python27-xia-mac-he-win-an-zhuang-jie-jue/</id>
        <link href="https://huyuwei1996.github.io/post/jpype1-python27-xia-mac-he-win-an-zhuang-jie-jue/">
        </link>
        <updated>2020-04-13T07:29:21.000Z</updated>
        <content type="html"><![CDATA[<h1 id="win">win</h1>
<p><code>pip2 install jpype1</code>安装失败<br>
在<a href="https://www.lfd.uci.edu/~gohlke/pythonlibs/#jpype">https://www.lfd.uci.edu/~gohlke/pythonlibs/#jpype</a> 下载cp27也就是对应python2.7的<br>
<img src="https://huyuwei1996.github.io//post-images/1586763262234.png" alt="" loading="lazy"><br>
然后使用<code>pip2 install JPype1-0.7.1-cp27-cp27m-win_amd64.whl</code>安装</p>
<h1 id="mac">mac</h1>
<p><code>pip2 install jpype1</code>安装失败<br>
在<a href="https://github.com/jpype-project/jpype/releases">https://github.com/jpype-project/jpype/releases</a> 下载v0.7.1的Source code<br>
(zip)<br>
因为0.7.2开始不支持python2.7，所以安装时候会一直报错。<br>
这里选择下载源码解压后，直接编译安装</p>
<pre><code>cd JPype1-0.7.1
python2 setup.py install
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[记一次libimobiledevice安装问题]]></title>
        <id>https://huyuwei1996.github.io/post/ji-yi-ci-libimobiledevice-an-zhuang-wen-ti/</id>
        <link href="https://huyuwei1996.github.io/post/ji-yi-ci-libimobiledevice-an-zhuang-wen-ti/">
        </link>
        <updated>2020-04-13T07:12:26.000Z</updated>
        <content type="html"><![CDATA[<p><img src="https://huyuwei1996.github.io//post-images/1586762260492.png" alt="" loading="lazy"><br>
直接记录下结果吧，图中3f64bbdc857512944b5bc7bb36f4d59191c25d14一直编译报错，afc.c的问题。</p>
<pre><code>brew install -v --HEAD libimobiledevice
# 安装失败后，切换上一个commit
cd /Users/huyuwei/Library/Caches/Homebrew/libimobiledevice--git
git checkout c0576790378daa45d43335d44c5caff04c270c94
brew install gnutls
brew install libgcrypt
./autogen.sh --disable-openssl
make
make install
</code></pre>
<p>解决经过：</p>
<pre><code>brew install -v --HEAD libimobiledevice
# 安装新版时候，中间安装了依赖python@3.8，和openssl@1.1，brew自动安装失败后，尝试以下命令依然失败
brew install -v --HEAD --fetch --build-from-source libimobiledevice
# 后面打算手动编译，链接相关依赖库
cd /Users/huyuwei/Library/Caches/Homebrew/libimobiledevice--git
export LDFLAGS=&quot;-L/usr/local/opt/python@3.8/lib:$LDFLAGS&quot;
export LDFLAGS=&quot;-L/usr/local/opt/openssl@1.1/lib:$LDFLAGS&quot;
export CPPFLAGS=&quot;-I/usr/local/opt/openssl@1.1/include&quot;
./autogen.sh
# 提示openssl版本不对(如下)，可能是这里LDFLAGS设置的问题，不太会弄
checking for openssl &gt;= 0.9.8... no
configure: error: OpenSSL support explicitly requested but OpenSSL could not be found
# 最后找到一种方式
brew install gnutls
brew install libgcrypt
./autogen.sh --disable-openssl
make
make install
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Sublime Text常用插件记录]]></title>
        <id>https://huyuwei1996.github.io/post/sublime-text-chang-yong-cha-jian-ji-lu/</id>
        <link href="https://huyuwei1996.github.io/post/sublime-text-chang-yong-cha-jian-ji-lu/">
        </link>
        <updated>2020-04-10T03:40:25.000Z</updated>
        <content type="html"><![CDATA[<h6 id="常用package">常用Package</h6>
<blockquote>
<p>Package Control<br>
ConvertToUTF8(支持GBK)<br>
Codecs33(支持GB2312)<br>
HTML-CSS-JS Prettify<br>
Keymaps<br>
MarkdownTOC<br>
Nodejs<br>
Python 3<br>
PackageResourceViewer<br>
SideBarEnhancements<br>
Material Theme<br>
Theme - Monokai Pro</p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[python判断系统类型]]></title>
        <id>https://huyuwei1996.github.io/post/python-pan-duan-xi-tong-lei-xing/</id>
        <link href="https://huyuwei1996.github.io/post/python-pan-duan-xi-tong-lei-xing/">
        </link>
        <updated>2020-04-10T03:40:12.000Z</updated>
        <content type="html"><![CDATA[<h2 id="osname">os.name</h2>
<p>该变量返回当前操作系统的类型</p>
<pre><code class="language-python">import os
print(os.name)
</code></pre>
<table>
<thead>
<tr>
<th style="text-align:center">系统</th>
<th style="text-align:center">返回值</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">linux</td>
<td style="text-align:center">posix</td>
</tr>
<tr>
<td style="text-align:center">windows</td>
<td style="text-align:center">nt</td>
</tr>
<tr>
<td style="text-align:center">java虚拟机</td>
<td style="text-align:center">java</td>
</tr>
</tbody>
</table>
<h2 id="sysplatform">sys.platform</h2>
<p>该变量返回当前系统的平台标识</p>
<pre><code class="language-python">import sys
print(sys.platform)
</code></pre>
<table>
<thead>
<tr>
<th style="text-align:center">系统</th>
<th style="text-align:center">返回值</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">linux</td>
<td style="text-align:center">linux</td>
</tr>
<tr>
<td style="text-align:center">windows</td>
<td style="text-align:center">win32</td>
</tr>
<tr>
<td style="text-align:center">windows/cygwin</td>
<td style="text-align:center">cygwin</td>
</tr>
<tr>
<td style="text-align:center">mac os x</td>
<td style="text-align:center">darwin</td>
</tr>
</tbody>
</table>
<h2 id="platformsystem">platform.system()</h2>
<p>返回当前操作系统的名字</p>
<pre><code class="language-python">import platform
print(platform.system())
</code></pre>
<p>例如Linux，Windows，Java，Darwin，...</p>
<pre><code>platform.platform()     #获取操作系统名称及版本号，如'Darwin-19.2.0-x86_64-i386-64bit'

platform.version()        #获取操作系统版本号，如'Darwin Kernel Version 19.2.0: Sat Nov  9 03:47:04 PST 2019; root:xnu-6153.61.1~20/RELEASE_X86_64'

platform.architecture()    #获取操作系统的位数，如('64bit', '')

platform.machine()     #计算机类型，如'x86_64'

platform.node()          #计算机的网络名称

platform.processor()    #计算机处理器信息，如'i386'

platform.uname()        #包含上面所有的信息汇总
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[oh-my-zsh安装]]></title>
        <id>https://huyuwei1996.github.io/post/oh-my-zsh-an-zhuang/</id>
        <link href="https://huyuwei1996.github.io/post/oh-my-zsh-an-zhuang/">
        </link>
        <updated>2020-04-10T03:39:41.000Z</updated>
        <content type="html"><![CDATA[<h2 id="安装步骤">安装步骤</h2>
<ol>
<li>zsh安装</li>
<li>oh-my-zsh安装、高亮&amp;自动补全插件安装</li>
<li>autojump插件安装</li>
</ol>
<h2 id="安装脚本">安装脚本</h2>
<p>MacOS:<br>
mac自带zsh</p>
<pre><code>sh -c &quot;$(curl -fsSL https://raw.githubusercontent.com/ohmyzsh/ohmyzsh/master/tools/install.sh)&quot;

git clone https://github.com/zsh-users/zsh-autosuggestions ${ZSH_CUSTOM:-~/.oh-my-zsh/custom}/plugins/zsh-autosuggestions
git clone https://github.com/zsh-users/zsh-syntax-highlighting.git ${ZSH_CUSTOM:-~/.oh-my-zsh/custom}/plugins/zsh-syntax-highlighting

brew install autojump

sed -i &quot;&quot; &quot;s/plugins=(git)/plugins=(git zsh-autosuggestions zsh-syntax-highlighting autojump)/g&quot; ~/.zshrc
source ~/.zshrc
</code></pre>
<p>Ubuntu:</p>
<pre><code>sudo apt update -y
sudo apt install zsh -y
sudo apt install git -y

sh -c &quot;$(curl -fsSL https://raw.githubusercontent.com/ohmyzsh/ohmyzsh/master/tools/install.sh)&quot;

git clone https://github.com/zsh-users/zsh-autosuggestions ${ZSH_CUSTOM:-~/.oh-my-zsh/custom}/plugins/zsh-autosuggestions
git clone https://github.com/zsh-users/zsh-syntax-highlighting.git ${ZSH_CUSTOM:-~/.oh-my-zsh/custom}/plugins/zsh-syntax-highlighting

sudo apt install autojump -y

sed -i &quot;s/plugins=(git)/plugins=(git zsh-autosuggestions zsh-syntax-highlighting autojump)/g&quot; ~/.zshrc
source ~/.zshrc
</code></pre>
<p>CentOS:</p>
<pre><code>sudo yum update -y
sudo yum install zsh -y
sudo yum install git -y

sh -c &quot;$(curl -fsSL https://raw.githubusercontent.com/ohmyzsh/ohmyzsh/master/tools/install.sh)&quot;

git clone https://github.com/zsh-users/zsh-autosuggestions ${ZSH_CUSTOM:-~/.oh-my-zsh/custom}/plugins/zsh-autosuggestions
git clone https://github.com/zsh-users/zsh-syntax-highlighting.git ${ZSH_CUSTOM:-~/.oh-my-zsh/custom}/plugins/zsh-syntax-highlighting

sudo yum install -y autojump-zsh

sed -i &quot;s/plugins=(git)/plugins=(git zsh-autosuggestions zsh-syntax-highlighting autojump)/g&quot; ~/.zshrc
source ~/.zshrc
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Mac launchctl 启动进程]]></title>
        <id>https://huyuwei1996.github.io/post/mac-launchctl-qi-dong-jin-cheng/</id>
        <link href="https://huyuwei1996.github.io/post/mac-launchctl-qi-dong-jin-cheng/">
        </link>
        <updated>2020-04-10T03:39:04.000Z</updated>
        <content type="html"><![CDATA[<h1>plist文件分布</h1>
<pre><code class="">/System/Library/LaunchDaemons/ （System-wide daemons provided by OS X）
其中 apache的httpd程序启动配置文件 org.apache.httpd.plist 就在这里。

/System/Library/LaunchAgents/ （由Mac OS X为用户定义的任务项）

/Library/LaunchDaemons （由管理员定义的守护进程任务项 ）

/Library/LaunchAgents （由管理员为用户定义的任务项 ）
如果放到/Library/LaunchAgents/下面的话，就是一开机就启动哦～

~/Library/LaunchAgents （ 由用户自己定义的任务项 ）
</code></pre>
<h1>launchctl 常用命令</h1>
<pre><code class="">1.显示当前的启动脚本
launchctl list

2.开机时自动启动Apache服务器
sudo launchctl load -w /System/Library/LaunchDaemons/org.apache.httpd.plist

3.设置开机启动并立即启动改服务
launchctl load -w   **.pist 

4. 设置开机启动但不立即启动服务 
launchctl load **.pist 

5. 停止正在运行的启动脚本
sudo launchctl unload [path/to/script]
6. 再加上-w选项即可去除开机启动
sudo launchctl unload -w [path/to/script]
</code></pre>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Linux内核参数优化]]></title>
        <id>https://huyuwei1996.github.io/post/linux-nei-he-can-shu-you-hua/</id>
        <link href="https://huyuwei1996.github.io/post/linux-nei-he-can-shu-you-hua/">
        </link>
        <updated>2019-11-01T07:22:54.000Z</updated>
        <summary type="html"><![CDATA[<blockquote>
<p>转自——高并发情况下Linux系统及kernel参数优化：<a href="https://www.linuxidc.com/Linux/2018-08/153369.htm">https://www.linuxidc.com/Linux/2018-08/153369.htm</a></p>
<p>调整了一下方便自己查看</p>
</blockquote>
]]></summary>
        <content type="html"><![CDATA[<blockquote>
<p>转自——高并发情况下Linux系统及kernel参数优化：<a href="https://www.linuxidc.com/Linux/2018-08/153369.htm">https://www.linuxidc.com/Linux/2018-08/153369.htm</a></p>
<p>调整了一下方便自己查看</p>
</blockquote>
<!-- more -->
<p>众所周知在默认参数情况下Linux对高并发支持并不好，主要受限于单进程最大打开文件数限制、内核TCP参数方面和IO事件分配机制等。下面就从几方面来调整使Linux系统能够支持高并发环境。</p>
<h4 id="iptables相关">Iptables相关</h4>
<p>如非必须，关掉或卸载iptables防火墙，并阻止kernel加载iptables模块。这些模块会影响并发性能。</p>
<h4 id="单进程最大打开文件数限制">单进程最大打开文件数限制</h4>
<p>一般的发行版，限制单进程最大可以打开1024个文件，这是远远不能满足高并发需求的，调整过程如下:</p>
<p>在#号提示符下敲入:</p>
<pre><code># ulimit –n 65535
</code></pre>
<p>将root启动的单一进程的最大可以打开的文件数设置为65535个。如果系统回显类似于“Operationnotpermitted”之类的话，说明上述限制修改失败，实际上是因为在中指定的数值超过了Linux系统对该用户打开文件数的软限制或硬限制。因此，就需要修改Linux系统对用户的关于打开文件数的软限制和硬限制。</p>
<p>第一步，修改limits.conf文件，并添加：</p>
<pre><code># vim /etc/security/limits.conf
* soft nofile 65535
* hard nofile 65535
</code></pre>
<p>可以写成</p>
<pre><code>* - nofile 65535
</code></pre>
<p>其中'*'号表示修改所有用户的限制；soft或hard指定要修改软限制还是硬限制；65536则指定了想要修改的新的限制值，即最大打开文件数(请注意软限制值要小于或等于硬限制)。修改完后保存文件。</p>
<p>第二步，修改/etc/pam.d/login文件，在文件中添加如下行：</p>
<pre><code># vim /etc/pam.d/login
session required /lib/security/pam_limits.so
</code></pre>
<p>这是告诉Linux在用户完成系统登录后，应该调用pam_limits.so模块来设置系统对该用户可使用的各种资源数量的最大限制(包括用户可打开的最大文件数限制)，而pam_limits.so模块就会从/etc/security/limits.conf文件中读取配置来设置这些限制值。修改完后保存此文件。</p>
<p>第三步，查看Linux系统级的最大打开文件数限制，使用如下命令：</p>
<pre><code># cat /proc/sys/fs/file-max
32568
</code></pre>
<p>这表明这台Linux系统最多允许同时打开(即包含所有用户打开文件数总和)32568个文件，是Linux系统级硬限制，所有用户级的打开文件数限制都不应超过这个数值。通常这个系统级硬限制是Linux系统在启动时根据系统硬件资源状况计算出来的最佳的最大同时打开文件数限制，如果没有特殊需要，不应该修改此限制，除非想为用户级打开文件数限制设置超过此限制的值。修改此硬限制的方法是修改/etc/sysctl.conf文件内fs.file-max= 131072</p>
<p>这是让Linux在启动完成后强行将系统级打开文件数硬限制设置为131072。修改完后保存此文件。</p>
<p>完成上述步骤后重启系统，一般情况下就可以将Linux系统对指定用户的单一进程允许同时打开的最大文件数限制设为指定的数值。如果重启后用ulimit-n命令查看用户可打开文件数限制仍然低于上述步骤中设置的最大值，这可能是因为在用户登录脚本/etc/profile中使用ulimit-n命令已经将用户可同时打开的文件数做了限制。由于通过ulimit-n修改系统对用户可同时打开文件的最大数限制时，新修改的值只能小于或等于上次ulimit-n设置的值，因此想用此命令增大这个限制值是不可能的。所以，如果有上述问题存在，就只能去打开/etc/profile脚本文件，在文件中查找是否使用了ulimit-n限制了用户可同时打开的最大文件数量，如果找到，则删除这行命令，或者将其设置的值改为合适的值，然后保存文件，用户退出并重新登录系统即可。</p>
<p>通过上述步骤，就为支持高并发TCP连接处理的通讯处理程序解除关于打开文件数量方面的系统限制。</p>
<h4 id="内核tcp参数方面">内核TCP参数方面</h4>
<p>Linux系统下，TCP连接断开后，会以TIME_WAIT状态保留一定的时间，然后才会释放端口。当并发请求过多的时候，就会产生大量的TIME_WAIT状态的连接，无法及时断开的话，会占用大量的端口资源和服务器资源。这个时候我们可以优化TCP的内核参数，来及时将TIME_WAIT状态的端口清理掉。</p>
<p>下面介绍的方法只对拥有大量TIME_WAIT状态的连接导致系统资源消耗有效，如果不是这种情况下，效果可能不明显。可以使用netstat命令去查TIME_WAIT状态的连接状态，输入下面的组合命令，查看当前TCP连接的状态和对应的连接数量：</p>
<pre><code># netstat -n | awk '/^tcp/ {++S[$NF]} END {for(a in S) print a, S[a]}'
</code></pre>
<p>这个命令会输出类似下面的结果：</p>
<p>LAST_ACK16<br>
SYN_RECV348<br>
ESTABLISHED70<br>
FIN_WAIT1229<br>
FIN_WAIT230<br>
CLOSING33<br>
TIME_WAIT18098</p>
<p>我们只用关心TIME_WAIT的个数，在这里可以看到，有18000多个TIME_WAIT，这样就占用了18000多个端口。要知道端口的数量只有65535个，占用一个少一个，会严重的影响到后继的新连接。这种情况下，我们就有必要调整下Linux的TCP内核参数，让系统更快的释放TIME_WAIT连接。</p>
<p>编辑配置文件:/etc/sysctl.conf，在这个文件中，加入下面的几行内容：</p>
<pre><code># vim /etc/sysctl.conf
net.ipv4.tcp_syncookies= 1
net.ipv4.tcp_tw_reuse= 1
net.ipv4.tcp_tw_recycle= 1
net.ipv4.tcp_fin_timeout= 30
</code></pre>
<p>输入下面的命令，让内核参数生效：</p>
<pre><code># sysctl -p
</code></pre>
<p>简单的说明上面的参数的含义：</p>
<pre><code>net.ipv4.tcp_syncookies= 1
#表示开启SYNCookies。当出现SYN等待队列溢出时，启用cookies来处理，可防范少量SYN***，默认为0，表示关闭；

net.ipv4.tcp_tw_reuse= 1
#表示开启重用。允许将TIME-WAITsockets重新用于新的TCP连接，默认为0，表示关闭；

net.ipv4.tcp_tw_recycle= 1
#表示开启TCP连接中TIME-WAITsockets的快速回收，默认为0，表示关闭；

net.ipv4.tcp_fin_timeout
#修改系統默认的TIMEOUT 时间。
</code></pre>
<p>在经过这样的调整之后，除了会进一步提升服务器的负载能力之外，还能够防御小流量程度的DoS、CC和SYN***。</p>
<p>此外，如果你的连接数本身就很多，我们可以再优化一下TCP的可使用端口范围，进一步提升服务器的并发能力。依然是往上面的参数文件中，加入下面这些配置：</p>
<pre><code>net.ipv4.tcp_keepalive_time= 1200
net.ipv4.ip_local_port_range= 1024 65535
net.ipv4.tcp_max_syn_backlog= 8192
net.ipv4.tcp_max_tw_buckets= 5000
</code></pre>
<p>这几个参数，建议只在流量非常大的服务器上开启，会有显著的效果。一般的流量小的服务器上，没有必要去设置这几个参数。</p>
<pre><code>net.ipv4.tcp_keepalive_time= 1200
#表示当keepalive起用的时候，TCP发送keepalive消息的频度。缺省是2小时，改为20分钟。

net.ipv4.ip_local_port_range= 1024 65535
#表示用于向外连接的端口范围。缺省情况下很小，改为1024到65535。

net.ipv4.tcp_max_syn_backlog= 8192
#表示SYN队列的长度，默认为1024，加大队列长度为8192，可以容纳更多等待连接的网络连接数。

net.ipv4.tcp_max_tw_buckets= 5000
#表示系统同时保持TIME_WAIT的最大数量，如果超过这个数字，TIME_WAIT将立刻被清除并打印警告信息。默认为180000，改为5000。此项参数可以控制TIME_WAIT的最大数量，只要超出了。
</code></pre>
<h4 id="内核其他tcp参数说明">内核其他TCP参数说明：</h4>
<pre><code>net.ipv4.tcp_max_syn_backlog= 65536
#记录的那些尚未收到客户端确认信息的连接请求的最大值。对于有128M内存的系统而言，缺省值是1024，小内存的系统则是128。

net.core.netdev_max_backlog= 32768
#每个网络接口接收数据包的速率比内核处理这些包的速率快时，允许送到队列的数据包的最大数目。

net.core.somaxconn= 32768
#例如web应用中listen函数的backlog默认会给我们内核参数的net.core.somaxconn限制到128，而nginx定义的NGX_LISTEN_BACKLOG默认为511，所以有必要调整这个值。

net.core.wmem_default= 8388608
net.core.rmem_default= 8388608
net.core.rmem_max= 16777216          #最大socket读buffer,可参考的优化值:873200
net.core.wmem_max= 16777216          #最大socket写buffer,可参考的优化值:873200
net.ipv4.tcp_timestsmps= 0
#时间戳可以避免序列号的卷绕。一个1Gbps的链路肯定会遇到以前用过的序列号。时间戳能够让内核接受这种“异常”的数据包。这里需要将其关掉。

net.ipv4.tcp_synack_retries= 2
#为了打开对端的连接，内核需要发送一个SYN并附带一个回应前面一个SYN的ACK。也就是所谓三次握手中的第二次握手。这个设置决定了内核放弃连接之前发送SYN+ACK包的数量。

net.ipv4.tcp_syn_retries= 2
#在内核放弃建立连接之前发送SYN包的数量。

#net.ipv4.tcp_tw_len= 1
net.ipv4.tcp_tw_reuse= 1
# 开启重用。允许将TIME-WAITsockets重新用于新的TCP连接。

net.ipv4.tcp_wmem= 8192 436600 873200
# TCP写buffer,可参考的优化值:8192 436600 873200

net.ipv4.tcp_rmem  = 32768 436600 873200
# TCP读buffer,可参考的优化值:32768 436600 873200

net.ipv4.tcp_mem= 94500000 91500000 92700000
# 同样有3个值,意思是:
net.ipv4.tcp_mem[0]:低于此值，TCP没有内存压力。
net.ipv4.tcp_mem[1]:在此值下，进入内存压力阶段。
net.ipv4.tcp_mem[2]:高于此值，TCP拒绝分配socket。
上述内存单位是页，而不是字节。可参考的优化值是:7864321048576 1572864

net.ipv4.tcp_max_orphans= 3276800
#系统中最多有多少个TCP套接字不被关联到任何一个用户文件句柄上。
如果超过这个数字，连接将即刻被复位并打印出警告信息。
这个限制仅仅是为了防止简单的DoS***，不能过分依靠它或者人为地减小这个值，
更应该增加这个值(如果增加了内存之后)。

net.ipv4.tcp_fin_timeout= 30
#如果套接字由本端要求关闭，这个参数决定了它保持在FIN-WAIT-2状态的时间。对端可以出错并永远不关闭连接，甚至意外当机。缺省值是60秒。2.2 内核的通常值是180秒，你可以按这个设置，但要记住的是，即使你的机器是一个轻载的WEB服务器，也有因为大量的死套接字而内存溢出的风险，FIN-WAIT-2的危险性比FIN-WAIT-1要小，因为它最多只能吃掉1.5K内存，但是它们的生存期长些。
</code></pre>
<p>同时还涉及到一个TCP 拥塞算法的问题，你可以用下面的命令查看本机提供的拥塞算法控制模块：</p>
<p>sysctlnet.ipv4.tcp_available_congestion_control</p>
<p>对于几种算法的分析，详情可以参考下：TCP拥塞控制算法的优缺点、适用环境、性能分析，比如高延时可以试用hybla，中等延时可以试用htcp算法等。</p>
<pre><code>如果想设置TCP 拥塞算法为hybla
net.ipv4.tcp_congestion_control=hybla

额外的，对于内核版高于于3.7.1的，我们可以开启tcp_fastopen：
net.ipv4.tcp_fastopen= 3
</code></pre>
<h4 id="io事件分配机制">IO事件分配机制</h4>
<p>在Linux启用高并发TCP连接，必须确认应用程序是否使用了合适的网络I/O技术和I/O事件分派机制。可用的I/O技术有同步I/O，非阻塞式同步I/O，以及异步I/O。在高TCP并发的情形下，如果使用同步I/O，这会严重阻塞程序的运转，除非为每个TCP连接的I/O创建一个线程。但是，过多的线程又会因系统对线程的调度造成巨大开销。因此，在高TCP并发的情形下使用同步I/O是不可取的，这时可以考虑使用非阻塞式同步I/O或异步I/O。非阻塞式同步I/O的技术包括使用select()，poll()，epoll等机制。异步I/O的技术就是使用AIO。</p>
<p>从I/O事件分派机制来看，使用select()是不合适的，因为它所支持的并发连接数有限(通常在1024个以内)。如果考虑性能，poll()也是不合适的，尽管它可以支持的较高的TCP并发数，但是由于其采用“轮询”机制，当并发数较高时，其运行效率相当低，并可能存在I/O事件分派不均，导致部分TCP连接上的I/O出现“饥饿”现象。而如果使用epoll或AIO，则没有上述问题(早期Linux内核的AIO技术实现是通过在内核中为每个I/O请求创建一个线程来实现的，这种实现机制在高并发TCP连接的情形下使用其实也有严重的性能问题。但在最新的Linux内核中，AIO的实现已经得到改进)。</p>
<p>综上所述，在开发支持高并发TCP连接的Linux应用程序时，应尽量使用epoll或AIO技术来实现并发的TCP连接上的I/O控制，这将为提升程序对高并发TCP连接的支持提供有效的I/O保证。</p>
<p>经过这样的优化配置之后，服务器的TCP并发处理能力会显著提高。以上配置仅供参考，用于生产环境请根据自己的实际情况调整观察再调整。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[常用算法速记-Python]]></title>
        <id>https://huyuwei1996.github.io/post/chang-yong-suan-fa-su-ji-python/</id>
        <link href="https://huyuwei1996.github.io/post/chang-yong-suan-fa-su-ji-python/">
        </link>
        <updated>2019-09-05T15:38:26.000Z</updated>
        <content type="html"><![CDATA[<h1 id="10-十大经典排序算法">1.0 十大经典排序算法</h1>
<figure data-type="image" tabindex="1"><img src="https://www.runoob.com/wp-content/uploads/2019/03/sort.png" alt="img" loading="lazy"></figure>
<figure data-type="image" tabindex="2"><img src="https://www.runoob.com/wp-content/uploads/2019/03/0B319B38-B70E-4118-B897-74EFA7E368F9.png" alt="img" loading="lazy"></figure>
<h1 id="11-冒泡排序">1.1 冒泡排序</h1>
<figure data-type="image" tabindex="3"><img src="https://www.runoob.com/wp-content/uploads/2019/03/bubbleSort.gif" alt="img" loading="lazy"></figure>
<pre><code class="language-python">def bubbleSort(arr):
    for i in range(1, len(arr)):
        for j in range(0, len(arr)-i):
            if arr[j] &gt; arr[j+1]:
                arr[j], arr[j + 1] = arr[j + 1], arr[j]
    return arr
</code></pre>
<h1 id="12-选择排序">1.2 选择排序</h1>
<figure data-type="image" tabindex="4"><img src="https://www.runoob.com/wp-content/uploads/2019/03/selectionSort.gif" alt="img" loading="lazy"></figure>
<pre><code class="language-python">def selectionSort(arr):
    for i in range(len(arr) - 1):
        # 记录最小数的索引
        minIndex = i
        for j in range(i + 1, len(arr)):
            if arr[j] &lt; arr[minIndex]:
                minIndex = j
        # i 不是最小数时，将 i 和最小数进行交换
        if i != minIndex:
            arr[i], arr[minIndex] = arr[minIndex], arr[i]
    return arr
</code></pre>
<h1 id="13-插入排序">1.3 插入排序</h1>
<figure data-type="image" tabindex="5"><img src="https://www.runoob.com/wp-content/uploads/2019/03/insertionSort.gif" alt="img" loading="lazy"></figure>
<pre><code class="language-python">def insertionSort(arr):
    for i in range(len(arr)):
        preIndex = i-1
        current = arr[i]
        while preIndex &gt;= 0 and arr[preIndex] &gt; current:
            arr[preIndex+1] = arr[preIndex]
            preIndex-=1
        arr[preIndex+1] = current
    return arr
</code></pre>
<h1 id="14-希尔排序">1.4 希尔排序</h1>
<figure data-type="image" tabindex="6"><img src="https://www.runoob.com/wp-content/uploads/2019/03/Sorting_shellsort_anim.gif" alt="img" loading="lazy"></figure>
<pre><code class="language-python">def shellSort(arr):
    import math
    gap=1
    while(gap &lt; len(arr)/3):
        gap = gap*3+1
    while gap &gt; 0:
        for i in range(gap,len(arr)):
            temp = arr[i]
            j = i-gap
            while j &gt;=0 and arr[j] &gt; temp:
                arr[j+gap]=arr[j]
                j-=gap
            arr[j+gap] = temp
        gap = math.floor(gap/3)
    return arr
</code></pre>
<h1 id="15-归并排序">1.5 归并排序</h1>
<figure data-type="image" tabindex="7"><img src="https://www.runoob.com/wp-content/uploads/2019/03/mergeSort.gif" alt="img" loading="lazy"></figure>
<pre><code class="language-python">def mergeSort(arr):
    import math
    if(len(arr)&lt;2):
        return arr
    middle = math.floor(len(arr)/2)
    left, right = arr[0:middle], arr[middle:]
    return merge(mergeSort(left), mergeSort(right))

def merge(left,right):
    result = []
    while left and right:
        if left[0] &lt;= right[0]:
            result.append(left.pop(0))
        else:
            result.append(right.pop(0));
    while left:
        result.append(left.pop(0))
    while right:
        result.append(right.pop(0));
    return result
</code></pre>
<h1 id="16-快速排序">1.6 快速排序</h1>
<figure data-type="image" tabindex="8"><img src="https://www.runoob.com/wp-content/uploads/2019/03/quickSort.gif" alt="img" loading="lazy"></figure>
<pre><code class="language-python">def quickSort(arr, left=None, right=None):
    left = 0 if not isinstance(left,(int, float)) else left
    right = len(arr)-1 if not isinstance(right,(int, float)) else right
    if left &lt; right:
        partitionIndex = partition(arr, left, right)
        quickSort(arr, left, partitionIndex-1)
        quickSort(arr, partitionIndex+1, right)
    return arr

def partition(arr, left, right):
    pivot = left
    index = pivot+1
    i = index
    while  i &lt;= right:
        if arr[i] &lt; arr[pivot]:
            swap(arr, i, index)
            index+=1
        i+=1
    swap(arr,pivot,index-1)
    return index-1

def swap(arr, i, j):
    arr[i], arr[j] = arr[j], arr[i]
</code></pre>
<h1 id="17-堆排序">1.7 堆排序</h1>
<figure data-type="image" tabindex="9"><img src="https://www.runoob.com/wp-content/uploads/2019/03/heapSort.gif" alt="img" loading="lazy"></figure>
<pre><code class="language-python">def buildMaxHeap(arr):
    import math
    for i in range(math.floor(len(arr)/2),-1,-1):
        heapify(arr,i)

def heapify(arr, i):
    left = 2*i+1
    right = 2*i+2
    largest = i
    if left &lt; arrLen and arr[left] &gt; arr[largest]:
        largest = left
    if right &lt; arrLen and arr[right] &gt; arr[largest]:
        largest = right

    if largest != i:
        swap(arr, i, largest)
        heapify(arr, largest)

def swap(arr, i, j):
    arr[i], arr[j] = arr[j], arr[i]

def heapSort(arr):
    global arrLen
    arrLen = len(arr)
    buildMaxHeap(arr)
    for i in range(len(arr)-1,0,-1):
        swap(arr,0,i)
        arrLen -=1
        heapify(arr, 0)
    return arr
</code></pre>
<h1 id="18-计数排序">1.8 计数排序</h1>
<figure data-type="image" tabindex="10"><img src="https://www.runoob.com/wp-content/uploads/2019/03/countingSort.gif" alt="img" loading="lazy"></figure>
<pre><code class="language-python">def countingSort(arr, maxValue):
    bucketLen = maxValue+1
    bucket = [0]*bucketLen
    sortedIndex =0
    arrLen = len(arr)
    for i in range(arrLen):
        if not bucket[arr[i]]:
            bucket[arr[i]]=0
        bucket[arr[i]]+=1
    for j in range(bucketLen):
        while bucket[j]&gt;0:
            arr[sortedIndex] = j
            sortedIndex+=1
            bucket[j]-=1
    return arr
</code></pre>
<h1 id="19-桶排序">1.9 桶排序</h1>
<figure data-type="image" tabindex="11"><img src="https://www.runoob.com/wp-content/uploads/2019/03/Bucket_sort_1.svg_.png" alt="img" loading="lazy"></figure>
<figure data-type="image" tabindex="12"><img src="https://www.runoob.com/wp-content/uploads/2019/03/Bucket_sort_2.svg_.png" alt="img" loading="lazy"></figure>
<h1 id="110-基数排序">1.10 基数排序</h1>
<figure data-type="image" tabindex="13"><img src="https://www.runoob.com/wp-content/uploads/2019/03/radixSort.gif" alt="img" loading="lazy"></figure>
<pre><code class="language-python">def radix(arr):
    
    digit = 0
    max_digit = 1
    max_value = max(arr)
    #找出列表中最大的位数
    while 10**max_digit &lt; max_value:
        max_digit = max_digit + 1
    
    while digit &lt; max_digit:
        temp = [[] for i in range(10)]
        for i in arr:
            #求出每一个元素的个、十、百位的值
            t = int((i/10**digit)%10)
            temp[t].append(i)
        
        coll = []
        for bucket in temp:
            for i in bucket:
                coll.append(i)
                
        arr = coll
        digit = digit + 1

    return arr
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[理财小白营]]></title>
        <id>https://huyuwei1996.github.io/post/li-cai-xiao-bai-ying/</id>
        <link href="https://huyuwei1996.github.io/post/li-cai-xiao-bai-ying/">
        </link>
        <updated>2019-09-01T15:42:51.000Z</updated>
        <content type="html"><![CDATA[<p>微信上报了个9元的课程，周末抽空补了下进度，还是尽快去补完进度，每天坚持了解一些。</p>
<h2 id="入门阅读">入门阅读</h2>
<h3 id="1小狗钱钱"><a href="https://docs.qq.com/doc/DWExvQ2ZmUGhxcmVw">1.《小狗钱钱》</a></h3>
<ul>
<li><a href="https://mp.weixin.qq.com/s/N-Al5hsUVihX0ehOy99_Hg">1.1 想变的有钱，这3个建议可以帮你</a>
<ul>
<li>1.1.1 缺钱的时候，钱就格外重要</li>
<li>1.1.2 不想一辈子就穷下去，现在就要学会理财</li>
<li>1.1.3 人的精力有限，删除干扰选项，才更有机会实现愿望</li>
<li>1.1.4 永远不要试试看，只有“做”或“不做”</li>
<li>总结
<ul>
<li>写下Top3愿望</li>
<li>制作梦想相册——激励和推动自己</li>
<li>准备梦想储蓄罐</li>
</ul>
</li>
</ul>
</li>
<li><a href="https://mp.weixin.qq.com/s/GHm4FIm82t0955xXDeK8TQ">1.2 赚钱没你想的那么难</a>
<ul>
<li>1.2.1 写“成功日记”
<ul>
<li>任何小事都可以，给自己加油、自信</li>
</ul>
</li>
<li>1.2.2 商人赚钱建议
<ul>
<li>为别人解决问题</li>
<li>把精力放在你知道的事情和能够做的事情上</li>
</ul>
</li>
<li>1.2.3 觉得钱难赚的人
<ul>
<li>没有认真思考
<ul>
<li>赚钱你要花费多少时间？</li>
</ul>
</li>
<li>不愿面对困难
<ul>
<li>找借口，放弃</li>
</ul>
</li>
</ul>
</li>
<li>总结
<ul>
<li>写“成功日记”，增加自信</li>
<li>别人需要什么？</li>
<li>我能做什么？</li>
</ul>
</li>
</ul>
</li>
<li><a href="https://mp.weixin.qq.com/s/BQ0AjU7epTCusNvL8k7Uog">1.3 99%的人不成功，都是因为它</a>
<ul>
<li>1.3.1 遇到困难的时候，越要坚持自己的想法</li>
<li>1.3.2 要每天不间断地去做对你未来意义重大的事
<ul>
<li>21天理论——坚持21天就会变成习惯</li>
</ul>
</li>
<li>1.3.3 当决定做一件事的时候，就要立即去做
<ul>
<li>否则很可能永远不会再去做</li>
</ul>
</li>
<li>总结
<ul>
<li>坚持最重要</li>
</ul>
</li>
</ul>
</li>
<li><a href="https://mp.weixin.qq.com/s/GFq6v8ZpD2-CP_YEqRT6IQ">1.4 不要杀死你的鹅</a>
<ul>
<li>1.4.1 不要杀死你的鹅
<ul>
<li>不要花光本金，否则永远不会有收益</li>
</ul>
</li>
<li>总结
<ul>
<li>负债的人应该扔掉所有信用卡
<ul>
<li>使用信用卡，总比使用现金花的多</li>
</ul>
</li>
<li>尽可能少的偿还贷款
<ul>
<li>如果是信用卡债还是建议先还债</li>
<li>还要考虑通货膨胀，以后钱会缩水</li>
</ul>
</li>
<li>对于消费贷款，应该将不用于生活的钱存起来一半，另一半用于还债
<ul>
<li>存钱，保证储蓄(本金)</li>
</ul>
</li>
<li>把想要的东西分为“必要、需要、想要”
<ul>
<li>控制消费</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="https://mp.weixin.qq.com/s/ICJtLRYf5UYkTpBjgOY8TA">1.5 投资，遵循这3个原则就足够了</a>
<ul>
<li>1.5.1 现金的重要性，应对突发情况
<ul>
<li>投资前，做好资产配置</li>
</ul>
</li>
<li>1.5.2 金钱能否带来幸福，取决于是否懂得怎样使用它</li>
<li>1.5.3 穷人思维
<ul>
<li>拿到钱买买买，吃喝玩乐，奢侈享受，忽略了投资</li>
</ul>
</li>
<li>1.5.4 富人思维
<ul>
<li>消费一些钱作为奖励，将80%甚至更多的钱投资，继续赚取更多的钱</li>
</ul>
</li>
<li>总结
<ul>
<li>投资要安全
<ul>
<li>本金不能丧失</li>
</ul>
</li>
<li>要有收益
<ul>
<li>先评估风险，再考虑收益多少</li>
</ul>
</li>
<li>充分了解投资对象
<ul>
<li>“不懂的就不要碰”</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="2晚间分享财富的载体时间量化思维"><a href="https://shimo.im/docs/660f6eab67a74f47/read">2.【晚间分享】财富的载体——时间&amp;量化思维</a></h3>
<ul>
<li>2.1 大多数人在工作和生活中，更多地注意金钱，而很少注意“时间”
<ul>
<li>有钱人会感觉时间比金钱重要，愿意用钱买时间</li>
<li>没钱的人更在乎钱，不在乎时间，愿意用时间做一些没什么价值的事情</li>
</ul>
</li>
<li>2.2 穷人思维
<ul>
<li>因为没钱，所以缓缓；等有钱了，怎样怎样</li>
<li>为免费、特价等，付出过多的资源和时间
<ul>
<li>可能浪费过多的时间和注意力</li>
</ul>
</li>
</ul>
</li>
<li>2.3 理财思维
<ul>
<li>重视时间成本</li>
</ul>
</li>
<li>2.4 不理财不等于没风险，通货膨胀其实就是最大的风险</li>
<li>2.5 “怕吃苦，吃苦一辈子，不怕苦，吃苦一阵子”</li>
<li>总结
<ul>
<li>每个人的时间都有一定的金钱价值
<ul>
<li>用凡事不要凭感觉，用量化思维计算，选择更有价值的事做</li>
</ul>
</li>
<li>金钱是有时间价值的，现在的钱比未来更值钱
<ul>
<li>提高投资能力，让钱更值钱</li>
</ul>
</li>
<li>学习是有时间成本的
<ul>
<li>学的越晚，消耗越大</li>
</ul>
</li>
</ul>
</li>
<li>拓展知识
<ul>
<li>投资的不可能三角
<ul>
<li>投资理财目标中，收益性、安全性、流动性三者，最多只能占两个
<ul>
<li>收益性、安全性、！流动性
<ul>
<li>房子</li>
</ul>
</li>
<li>安全性、流动性、！收益性
<ul>
<li>活期存款、货币基金等</li>
</ul>
</li>
<li>收益性、流动性、！安全性
<ul>
<li>部分P2P</li>
</ul>
</li>
</ul>
</li>
<li>通过投资资产的三种属性，判断投资品种是否靠谱</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="3晨读美文两种思维方式决定了你只能当穷人"><a href="https://docs.qq.com/doc/DR3ZjZHBVdk5adVBa">3.【晨读美文】两种思维方式决定了你只能当穷人</a></h3>
<h3 id="4午间茶馆小狗钱钱拆读"><a href="https://docs.qq.com/doc/DR2dRWldBR0ZQVGNp">4.【午间茶馆】《小狗钱钱》拆读</a></h3>
<h3 id="5晚间分享玩转信用卡"><a href="https://docs.qq.com/doc/DR25ZdVZkVFhRSnR1">5.【晚间分享】玩转信用卡</a></h3>
<h3 id="6晨读美文-要为你的未来花点钱"><a href="https://docs.qq.com/doc/DWGRkcEx0YWFBVGlO">6.【晨读美文】-要为你的未来花点钱</a></h3>
<p><em>XMind: ZEN - Trial Version</em><br>
<img src="https://huyuwei1996.github.io//post-images/1567352666078.png" alt="" loading="lazy"></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[数据结构与算法-Python]]></title>
        <id>https://huyuwei1996.github.io/post/suan-fa-xue-xi-python/</id>
        <link href="https://huyuwei1996.github.io/post/suan-fa-xue-xi-python/">
        </link>
        <updated>2019-08-31T13:21:20.000Z</updated>
        <content type="html"><![CDATA[<h2 id="算法的五大特性">算法的五大特性</h2>
<ol>
<li>
<p><strong>输入</strong>：算法具有0个或者多个输入</p>
</li>
<li>
<p><strong>输出</strong>：算法至少有1个或者多个输出</p>
</li>
<li>
<p><strong>有穷性</strong>：算法在有限的步骤之后会自动结束而不会无线循环，并且，每一个步骤在一个可接受的时间内完成</p>
</li>
<li>
<p><strong>确定性</strong>：算法中的每一步都有确定的定义，不会出现二义性</p>
</li>
<li>
<p><strong>可行性</strong>：算法的每一步都是可行的，也就是说每一步都能够执行有限次数的完成</p>
</li>
</ol>
<h2 id="时间复杂度与大o表示法">时间复杂度与大O表示法</h2>
<ul>
<li><strong>最优时间复杂度</strong></li>
<li><strong>最坏时间复杂度</strong></li>
<li><strong>平均时间复杂度</strong></li>
</ul>
<p>主要关注算法的最坏情况，即<strong>最坏时间复杂度</strong></p>
<h3 id="时间复杂度的几条计算基本规则">时间复杂度的几条计算基本规则</h3>
<ol>
<li>
<p>基本操作，即只有常数项，认为其时间复杂度为<strong>O(1)</strong></p>
</li>
<li>
<p>顺序结构，时间复杂度按<strong>加法</strong>进行计算</p>
</li>
<li>
<p>循环结构，时间复杂度按<strong>乘法</strong>进行计算</p>
</li>
<li>
<p>分支结构，时间复杂度<strong>取最大值</strong></p>
</li>
<li>
<p>判断一个算法的效率时，往往只需要关注操作数量的<strong>最高项</strong>，其次要项和常数项可以忽略</p>
</li>
<li>
<p>在没有特殊说明时，我们所分析的算法的时间复杂度都是指<strong>最坏时间复杂度</strong></p>
</li>
</ol>
<h2 id="常见时间复杂度">常见时间复杂度</h2>
<h3 id="常见时间复杂度直接的关系">常见时间复杂度直接的关系</h3>
<p><strong>O(1) &lt; O(logn) &lt; O(n) &lt; O(nlogn) &lt; O(n<sup>2</sup>) &lt; O(n<sup>2</sup>logn) &lt; O(n<sup>3</sup>) &lt; O(2<sup>n</sup>) &lt; O(n!) &lt; O(n<sup>n</sup>)</strong></p>
<h2 id="python内置类型性能分析">Python内置类型性能分析</h2>
<h3 id="timeit模块">timeit模块</h3>
<p><strong>class timeit.Timer(stmt='pass', setup='pass', timer=&lt;timer function&gt;)</strong></p>
<p><strong>timeit.Timer.timeit(number=1000000)</strong></p>
<p>测试代码时的测试次数，默认为1000000次</p>
<h3 id="list内置操作的时间复杂度">list内置操作的时间复杂度</h3>
<h3 id="dict内置操作的时间复杂度">dict内置操作的时间复杂度</h3>
<h2 id="数据结构">数据结构</h2>
<h3 id="概念">概念</h3>
<h3 id="算法与数据结构的区别">算法与数据结构的区别</h3>
<p>程序 = 算法 + 数据结构</p>
<h3 id="抽象数据类型abstract-data-type-简称adt">抽象数据类型(Abstract Data Type 简称ADT)</h3>
<h2 id="顺序表的结构和实现">顺序表的结构和实现</h2>
<h3 id="顺序表的结构">顺序表的结构</h3>
<h3 id="顺序表的两种基本实现方式">顺序表的两种基本实现方式</h3>
<ul>
<li>一体式结构</li>
<li>分离式结构</li>
</ul>
<h3 id="元素存储区替换">元素存储区替换</h3>
<h3 id="元素存储区扩充">元素存储区扩充</h3>
<h4 id="扩充的两种策略">扩充的两种策略</h4>
<p>第二种=用空间换时间</p>
<h2 id="顺序表的操作">顺序表的操作</h2>
<h3 id="增加元素">增加元素</h3>
<h3 id="删除元素">删除元素</h3>
<h2 id="python中的顺序表">Python中的顺序表</h2>
<p>Python中的list和tuple两种类型采用了顺序表的实现技术</p>
<h3 id="list的基本实现技术">list的基本实现技术</h3>
<h2 id="链表">链表</h2>
<h3 id="单向链表">单向链表</h3>
<h4 id="操作">操作</h4>
<h4 id="实现">实现</h4>
<pre><code class="language-python">class Node(object):
    &quot;&quot;&quot;节点&quot;&quot;&quot;

    def __init__(self, item):
        self.item = item
        self.next = None


class SingleLinkList(object):
    &quot;&quot;&quot;单链表&quot;&quot;&quot;

    def __init__(self, node=None):
        self.__head = node  # 私有属性

    def is_empty(self):
        &quot;&quot;&quot;链表是否为空&quot;&quot;&quot;
        return self.__head is None

    def length(self):
        &quot;&quot;&quot;链表长度&quot;&quot;&quot;
        # cursor游标，用来移动，遍历节点
        cur = self.__head
        # count计数
        count = 0
        while cur is not None:
            count += 1
            cur = cur.next
        return count

    def travel(self):
        &quot;&quot;&quot;遍历整个链表&quot;&quot;&quot;
        # cursor游标，用来移动，遍历节点
        cur = self.__head
        while cur is not None:
            print(cur.item, end=&quot; &quot;)
            cur = cur.next
        print(&quot;&quot;)

    def add(self, item):
        &quot;&quot;&quot;链表头部添加元素，头插法&quot;&quot;&quot;
        node = Node(item)
        if self.is_empty():
            self.__head = node
        else:
            node.next = self.__head
            self.__head = node

    def append(self, item):
        &quot;&quot;&quot;链表尾部添加元素，尾插法&quot;&quot;&quot;
        node = Node(item)
        if self.is_empty():
            self.__head = node
        else:
            cur = self.__head
            while cur.next is not None:
                cur = cur.next
            cur.next = node

    def insert(self, pos, item):
        &quot;&quot;&quot;指定位置添加元素
        :param pos 位置
        &quot;&quot;&quot;
        if pos &lt;= 0:
            self.add(item)
        elif pos &gt; (self.length() - 1):
            self.append(item)
        else:
            # pre
            pre = self.__head
            count = 0
            while count &lt; (pos - 1):
                count += 1
                pre = pre.next
            # 退出循环后。pre指向pos-1位置
            node = Node(item)
            node.next = pre.next
            pre.next = node

    def remove(self, item):
        &quot;&quot;&quot;删除节点&quot;&quot;&quot;
        cur = self.__head
        pre = None
        while cur is not None:
            if cur.item == item:
                # 先判断此节点是否头节点
                if cur == self.__head:
                    self.__head = cur.next
                else:
                    pre.next = cur.next
                break
            else:
                pre = cur
                cur = cur.next

    def search(self, item):
        &quot;&quot;&quot;查找节点是否存在&quot;&quot;&quot;
        cur = self.__head
        while cur is not None:
            if cur.item == item:
                return True
            else:
                cur = cur.next
        return False


if __name__ == '__main__':
    n = Node(100)
    sll = SingleLinkList()
    print('链表是否为空', sll.is_empty())
    print('链表长度', sll.length())
    sll.append(1)
    sll.append(2)
    sll.append(3)
    sll.add(4)
    sll.insert(0, 5)
    sll.insert(5, 10)
    sll.insert(2, 7)
    print('链表是否为空', sll.is_empty())
    print('链表长度', sll.length())
    sll.travel()
    print('查找节点是否存在', sll.search(1))
    sll.remove(5)
    sll.travel()
    sll.remove(10)
    sll.travel()
    sll.remove(2)
    sll.travel()

</code></pre>
<h4 id="链表与顺序表对比">链表与顺序表对比</h4>
<h3 id="双向链表">双向链表</h3>
<h4 id="操作-2">操作</h4>
<h4 id="实现-2">实现</h4>
<pre><code class="language-python">class DoubleNode(object):
    &quot;&quot;&quot;节点&quot;&quot;&quot;

    def __init__(self, item):
        self.item = item
        self.next = None
        self.prev = None


class DoubleLinkList(object):
    &quot;&quot;&quot;双向链表&quot;&quot;&quot;

    def __init__(self, node=None):
        self.__head = node  # 私有属性

    def is_empty(self):
        &quot;&quot;&quot;链表是否为空&quot;&quot;&quot;
        return self.__head is None

    def length(self):
        &quot;&quot;&quot;链表长度&quot;&quot;&quot;
        # cursor游标，用来移动，遍历节点
        cur = self.__head
        # count计数
        count = 0
        while cur is not None:
            count += 1
            cur = cur.next
        return count

    def travel(self):
        &quot;&quot;&quot;遍历整个链表&quot;&quot;&quot;
        # cursor游标，用来移动，遍历节点
        cur = self.__head
        while cur is not None:
            print(cur.item, end=&quot; &quot;)
            cur = cur.next
        print(&quot;&quot;)

    def add(self, item):
        &quot;&quot;&quot;链表头部添加元素，头插法&quot;&quot;&quot;
        node = DoubleNode(item)
        # # function 1
        # node.next = self.__head
        # self.__head = node
        # node.next.prev = node

        # function 2
        node.next = self.__head
        self.__head.prev = node
        self.__head = node

    def append(self, item):
        &quot;&quot;&quot;链表尾部添加元素，尾插法&quot;&quot;&quot;
        node = DoubleNode(item)
        if self.is_empty():
            self.__head = node
        else:
            cur = self.__head
            while cur.next is not None:
                cur = cur.next
            cur.next = node
            node.prev = cur

    def insert(self, pos, item):
        &quot;&quot;&quot;指定位置添加元素
        :param pos 位置
        &quot;&quot;&quot;
        if pos &lt;= 0:
            self.add(item)
        elif pos &gt; (self.length() - 1):
            self.append(item)
        else:
            cur = self.__head
            count = 0

            while count &lt; pos:
                count += 1
                cur = cur.next
            node = DoubleNode(item)
            node.next = cur
            node.prev = cur.prev
            # function 1
            cur.prev.next = node
            cur.prev = node

            # # function 2
            # cur.prev = node
            # cur.prev.next = node

    def remove(self, item):
        &quot;&quot;&quot;删除节点&quot;&quot;&quot;
        cur = self.__head
        while cur is not None:
            if cur.item == item:
                # 判断是否头节点
                if cur == self.__head:
                    self.__head = cur.next
                    if cur.next:
                        # 判断链表是否只有一个节点
                        cur.next.prev = None
                else:
                    cur.prev.next = cur.next
                    if cur.next:
                        cur.next.prev = cur.prev
                break
            else:
                cur = cur.next

    def search(self, item):
        &quot;&quot;&quot;查找节点是否存在&quot;&quot;&quot;
        cur = self.__head
        while cur is not None:
            if cur.item == item:
                return True
            else:
                cur = cur.next
        return False


if __name__ == '__main__':
    n = DoubleNode(100)
    dll = DoubleLinkList()
    print('链表是否为空', dll.is_empty())
    print('链表长度', dll.length())
    dll.append(1)
    dll.append(2)
    dll.append(3)
    dll.add(4)
    dll.insert(0, 5)
    dll.insert(5, 10)
    dll.insert(2, 7)
    print('链表是否为空', dll.is_empty())
    print('链表长度', dll.length())
    dll.travel()
    dll.remove(2)
    dll.travel()
    dll.remove(5)
    dll.travel()
    dll.remove(10)
    dll.travel()
    print('查找节点是否存在', dll.search(1))

</code></pre>
<h3 id="单项循环链表">单项循环链表</h3>
]]></content>
    </entry>
</feed>