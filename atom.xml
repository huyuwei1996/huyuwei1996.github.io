<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://huyuwei1996.github.io/</id>
    <title>Huyuwei’s Blog</title>
    <updated>2019-11-11T02:30:31.010Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://huyuwei1996.github.io/"/>
    <link rel="self" href="https://huyuwei1996.github.io//atom.xml"/>
    <subtitle>学习使人进步</subtitle>
    <logo>https://huyuwei1996.github.io//images/avatar.png</logo>
    <icon>https://huyuwei1996.github.io//favicon.ico</icon>
    <rights>All rights reserved 2019, Huyuwei’s Blog</rights>
    <entry>
        <title type="html"><![CDATA[Markdown常用转义字符]]></title>
        <id>https://huyuwei1996.github.io//post/markdown-chang-yong-zhuan-yi-zi-fu</id>
        <link href="https://huyuwei1996.github.io//post/markdown-chang-yong-zhuan-yi-zi-fu">
        </link>
        <updated>2019-11-08T07:34:35.000Z</updated>
        <content type="html"><![CDATA[<figure data-type="image" tabindex="1"><img src="https://huyuwei1996.github.io//post-images/1573198539277.png" alt=""></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Jmeter-几种json包使用方法]]></title>
        <id>https://huyuwei1996.github.io//post/jmeter-ji-chong-json-bao-shi-yong-fang-fa</id>
        <link href="https://huyuwei1996.github.io//post/jmeter-ji-chong-json-bao-shi-yong-fang-fa">
        </link>
        <updated>2019-11-08T07:31:05.000Z</updated>
        <content type="html"><![CDATA[<p>[TOC]</p>
<h1 id="json-path使用方法">json-path使用方法</h1>
<h2 id="语法格式">语法格式</h2>
<table>
<thead>
<tr>
<th>JsonPath</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>$</td>
<td>根节点</td>
</tr>
<tr>
<td>@</td>
<td></td>
</tr>
<tr>
<td>.or[]</td>
<td></td>
</tr>
<tr>
<td>..</td>
<td></td>
</tr>
<tr>
<td>*</td>
<td></td>
</tr>
<tr>
<td>[]</td>
<td></td>
</tr>
<tr>
<td>[,]</td>
<td></td>
</tr>
<tr>
<td>[start🔚step]</td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
</tbody>
</table>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Linux内核参数优化]]></title>
        <id>https://huyuwei1996.github.io//post/linux-nei-he-can-shu-you-hua</id>
        <link href="https://huyuwei1996.github.io//post/linux-nei-he-can-shu-you-hua">
        </link>
        <updated>2019-11-01T07:22:54.000Z</updated>
        <summary type="html"><![CDATA[<blockquote>
<p>转自——高并发情况下Linux系统及kernel参数优化：<a href="https://www.linuxidc.com/Linux/2018-08/153369.htm">https://www.linuxidc.com/Linux/2018-08/153369.htm</a></p>
<p>调整了一下方便自己查看</p>
</blockquote>
]]></summary>
        <content type="html"><![CDATA[<blockquote>
<p>转自——高并发情况下Linux系统及kernel参数优化：<a href="https://www.linuxidc.com/Linux/2018-08/153369.htm">https://www.linuxidc.com/Linux/2018-08/153369.htm</a></p>
<p>调整了一下方便自己查看</p>
</blockquote>
<!-- more -->
<p>众所周知在默认参数情况下Linux对高并发支持并不好，主要受限于单进程最大打开文件数限制、内核TCP参数方面和IO事件分配机制等。下面就从几方面来调整使Linux系统能够支持高并发环境。</p>
<h4 id="iptables相关">Iptables相关</h4>
<p>如非必须，关掉或卸载iptables防火墙，并阻止kernel加载iptables模块。这些模块会影响并发性能。</p>
<h4 id="单进程最大打开文件数限制">单进程最大打开文件数限制</h4>
<p>一般的发行版，限制单进程最大可以打开1024个文件，这是远远不能满足高并发需求的，调整过程如下:</p>
<p>在#号提示符下敲入:</p>
<pre><code># ulimit –n 65535
</code></pre>
<p>将root启动的单一进程的最大可以打开的文件数设置为65535个。如果系统回显类似于“Operationnotpermitted”之类的话，说明上述限制修改失败，实际上是因为在中指定的数值超过了Linux系统对该用户打开文件数的软限制或硬限制。因此，就需要修改Linux系统对用户的关于打开文件数的软限制和硬限制。</p>
<p>第一步，修改limits.conf文件，并添加：</p>
<pre><code># vim /etc/security/limits.conf
* soft nofile 65535
* hard nofile 65535
</code></pre>
<p>可以写成</p>
<pre><code>* - nofile 65535
</code></pre>
<p>其中'*'号表示修改所有用户的限制；soft或hard指定要修改软限制还是硬限制；65536则指定了想要修改的新的限制值，即最大打开文件数(请注意软限制值要小于或等于硬限制)。修改完后保存文件。</p>
<p>第二步，修改/etc/pam.d/login文件，在文件中添加如下行：</p>
<pre><code># vim /etc/pam.d/login
session required /lib/security/pam_limits.so
</code></pre>
<p>这是告诉Linux在用户完成系统登录后，应该调用pam_limits.so模块来设置系统对该用户可使用的各种资源数量的最大限制(包括用户可打开的最大文件数限制)，而pam_limits.so模块就会从/etc/security/limits.conf文件中读取配置来设置这些限制值。修改完后保存此文件。</p>
<p>第三步，查看Linux系统级的最大打开文件数限制，使用如下命令：</p>
<pre><code># cat /proc/sys/fs/file-max
32568
</code></pre>
<p>这表明这台Linux系统最多允许同时打开(即包含所有用户打开文件数总和)32568个文件，是Linux系统级硬限制，所有用户级的打开文件数限制都不应超过这个数值。通常这个系统级硬限制是Linux系统在启动时根据系统硬件资源状况计算出来的最佳的最大同时打开文件数限制，如果没有特殊需要，不应该修改此限制，除非想为用户级打开文件数限制设置超过此限制的值。修改此硬限制的方法是修改/etc/sysctl.conf文件内fs.file-max= 131072</p>
<p>这是让Linux在启动完成后强行将系统级打开文件数硬限制设置为131072。修改完后保存此文件。</p>
<p>完成上述步骤后重启系统，一般情况下就可以将Linux系统对指定用户的单一进程允许同时打开的最大文件数限制设为指定的数值。如果重启后用ulimit-n命令查看用户可打开文件数限制仍然低于上述步骤中设置的最大值，这可能是因为在用户登录脚本/etc/profile中使用ulimit-n命令已经将用户可同时打开的文件数做了限制。由于通过ulimit-n修改系统对用户可同时打开文件的最大数限制时，新修改的值只能小于或等于上次ulimit-n设置的值，因此想用此命令增大这个限制值是不可能的。所以，如果有上述问题存在，就只能去打开/etc/profile脚本文件，在文件中查找是否使用了ulimit-n限制了用户可同时打开的最大文件数量，如果找到，则删除这行命令，或者将其设置的值改为合适的值，然后保存文件，用户退出并重新登录系统即可。</p>
<p>通过上述步骤，就为支持高并发TCP连接处理的通讯处理程序解除关于打开文件数量方面的系统限制。</p>
<h4 id="内核tcp参数方面">内核TCP参数方面</h4>
<p>Linux系统下，TCP连接断开后，会以TIME_WAIT状态保留一定的时间，然后才会释放端口。当并发请求过多的时候，就会产生大量的TIME_WAIT状态的连接，无法及时断开的话，会占用大量的端口资源和服务器资源。这个时候我们可以优化TCP的内核参数，来及时将TIME_WAIT状态的端口清理掉。</p>
<p>下面介绍的方法只对拥有大量TIME_WAIT状态的连接导致系统资源消耗有效，如果不是这种情况下，效果可能不明显。可以使用netstat命令去查TIME_WAIT状态的连接状态，输入下面的组合命令，查看当前TCP连接的状态和对应的连接数量：</p>
<pre><code># netstat -n | awk '/^tcp/ {++S[$NF]} END {for(a in S) print a, S[a]}'
</code></pre>
<p>这个命令会输出类似下面的结果：</p>
<p>LAST_ACK16<br>
SYN_RECV348<br>
ESTABLISHED70<br>
FIN_WAIT1229<br>
FIN_WAIT230<br>
CLOSING33<br>
TIME_WAIT18098</p>
<p>我们只用关心TIME_WAIT的个数，在这里可以看到，有18000多个TIME_WAIT，这样就占用了18000多个端口。要知道端口的数量只有65535个，占用一个少一个，会严重的影响到后继的新连接。这种情况下，我们就有必要调整下Linux的TCP内核参数，让系统更快的释放TIME_WAIT连接。</p>
<p>编辑配置文件:/etc/sysctl.conf，在这个文件中，加入下面的几行内容：</p>
<pre><code># vim /etc/sysctl.conf
net.ipv4.tcp_syncookies= 1
net.ipv4.tcp_tw_reuse= 1
net.ipv4.tcp_tw_recycle= 1
net.ipv4.tcp_fin_timeout= 30
</code></pre>
<p>输入下面的命令，让内核参数生效：</p>
<pre><code># sysctl -p
</code></pre>
<p>简单的说明上面的参数的含义：</p>
<pre><code>net.ipv4.tcp_syncookies= 1
#表示开启SYNCookies。当出现SYN等待队列溢出时，启用cookies来处理，可防范少量SYN***，默认为0，表示关闭；

net.ipv4.tcp_tw_reuse= 1
#表示开启重用。允许将TIME-WAITsockets重新用于新的TCP连接，默认为0，表示关闭；

net.ipv4.tcp_tw_recycle= 1
#表示开启TCP连接中TIME-WAITsockets的快速回收，默认为0，表示关闭；

net.ipv4.tcp_fin_timeout
#修改系統默认的TIMEOUT 时间。
</code></pre>
<p>在经过这样的调整之后，除了会进一步提升服务器的负载能力之外，还能够防御小流量程度的DoS、CC和SYN***。</p>
<p>此外，如果你的连接数本身就很多，我们可以再优化一下TCP的可使用端口范围，进一步提升服务器的并发能力。依然是往上面的参数文件中，加入下面这些配置：</p>
<pre><code>net.ipv4.tcp_keepalive_time= 1200
net.ipv4.ip_local_port_range= 1024 65535
net.ipv4.tcp_max_syn_backlog= 8192
net.ipv4.tcp_max_tw_buckets= 5000
</code></pre>
<p>这几个参数，建议只在流量非常大的服务器上开启，会有显著的效果。一般的流量小的服务器上，没有必要去设置这几个参数。</p>
<pre><code>net.ipv4.tcp_keepalive_time= 1200
#表示当keepalive起用的时候，TCP发送keepalive消息的频度。缺省是2小时，改为20分钟。

net.ipv4.ip_local_port_range= 1024 65535
#表示用于向外连接的端口范围。缺省情况下很小，改为1024到65535。

net.ipv4.tcp_max_syn_backlog= 8192
#表示SYN队列的长度，默认为1024，加大队列长度为8192，可以容纳更多等待连接的网络连接数。

net.ipv4.tcp_max_tw_buckets= 5000
#表示系统同时保持TIME_WAIT的最大数量，如果超过这个数字，TIME_WAIT将立刻被清除并打印警告信息。默认为180000，改为5000。此项参数可以控制TIME_WAIT的最大数量，只要超出了。
</code></pre>
<h4 id="内核其他tcp参数说明">内核其他TCP参数说明：</h4>
<pre><code>net.ipv4.tcp_max_syn_backlog= 65536
#记录的那些尚未收到客户端确认信息的连接请求的最大值。对于有128M内存的系统而言，缺省值是1024，小内存的系统则是128。

net.core.netdev_max_backlog= 32768
#每个网络接口接收数据包的速率比内核处理这些包的速率快时，允许送到队列的数据包的最大数目。

net.core.somaxconn= 32768
#例如web应用中listen函数的backlog默认会给我们内核参数的net.core.somaxconn限制到128，而nginx定义的NGX_LISTEN_BACKLOG默认为511，所以有必要调整这个值。

net.core.wmem_default= 8388608
net.core.rmem_default= 8388608
net.core.rmem_max= 16777216          #最大socket读buffer,可参考的优化值:873200
net.core.wmem_max= 16777216          #最大socket写buffer,可参考的优化值:873200
net.ipv4.tcp_timestsmps= 0
#时间戳可以避免序列号的卷绕。一个1Gbps的链路肯定会遇到以前用过的序列号。时间戳能够让内核接受这种“异常”的数据包。这里需要将其关掉。

net.ipv4.tcp_synack_retries= 2
#为了打开对端的连接，内核需要发送一个SYN并附带一个回应前面一个SYN的ACK。也就是所谓三次握手中的第二次握手。这个设置决定了内核放弃连接之前发送SYN+ACK包的数量。

net.ipv4.tcp_syn_retries= 2
#在内核放弃建立连接之前发送SYN包的数量。

#net.ipv4.tcp_tw_len= 1
net.ipv4.tcp_tw_reuse= 1
# 开启重用。允许将TIME-WAITsockets重新用于新的TCP连接。

net.ipv4.tcp_wmem= 8192 436600 873200
# TCP写buffer,可参考的优化值:8192 436600 873200

net.ipv4.tcp_rmem  = 32768 436600 873200
# TCP读buffer,可参考的优化值:32768 436600 873200

net.ipv4.tcp_mem= 94500000 91500000 92700000
# 同样有3个值,意思是:
net.ipv4.tcp_mem[0]:低于此值，TCP没有内存压力。
net.ipv4.tcp_mem[1]:在此值下，进入内存压力阶段。
net.ipv4.tcp_mem[2]:高于此值，TCP拒绝分配socket。
上述内存单位是页，而不是字节。可参考的优化值是:7864321048576 1572864

net.ipv4.tcp_max_orphans= 3276800
#系统中最多有多少个TCP套接字不被关联到任何一个用户文件句柄上。
如果超过这个数字，连接将即刻被复位并打印出警告信息。
这个限制仅仅是为了防止简单的DoS***，不能过分依靠它或者人为地减小这个值，
更应该增加这个值(如果增加了内存之后)。

net.ipv4.tcp_fin_timeout= 30
#如果套接字由本端要求关闭，这个参数决定了它保持在FIN-WAIT-2状态的时间。对端可以出错并永远不关闭连接，甚至意外当机。缺省值是60秒。2.2 内核的通常值是180秒，你可以按这个设置，但要记住的是，即使你的机器是一个轻载的WEB服务器，也有因为大量的死套接字而内存溢出的风险，FIN-WAIT-2的危险性比FIN-WAIT-1要小，因为它最多只能吃掉1.5K内存，但是它们的生存期长些。
</code></pre>
<p>同时还涉及到一个TCP 拥塞算法的问题，你可以用下面的命令查看本机提供的拥塞算法控制模块：</p>
<p>sysctlnet.ipv4.tcp_available_congestion_control</p>
<p>对于几种算法的分析，详情可以参考下：TCP拥塞控制算法的优缺点、适用环境、性能分析，比如高延时可以试用hybla，中等延时可以试用htcp算法等。</p>
<pre><code>如果想设置TCP 拥塞算法为hybla
net.ipv4.tcp_congestion_control=hybla

额外的，对于内核版高于于3.7.1的，我们可以开启tcp_fastopen：
net.ipv4.tcp_fastopen= 3
</code></pre>
<h4 id="io事件分配机制">IO事件分配机制</h4>
<p>在Linux启用高并发TCP连接，必须确认应用程序是否使用了合适的网络I/O技术和I/O事件分派机制。可用的I/O技术有同步I/O，非阻塞式同步I/O，以及异步I/O。在高TCP并发的情形下，如果使用同步I/O，这会严重阻塞程序的运转，除非为每个TCP连接的I/O创建一个线程。但是，过多的线程又会因系统对线程的调度造成巨大开销。因此，在高TCP并发的情形下使用同步I/O是不可取的，这时可以考虑使用非阻塞式同步I/O或异步I/O。非阻塞式同步I/O的技术包括使用select()，poll()，epoll等机制。异步I/O的技术就是使用AIO。</p>
<p>从I/O事件分派机制来看，使用select()是不合适的，因为它所支持的并发连接数有限(通常在1024个以内)。如果考虑性能，poll()也是不合适的，尽管它可以支持的较高的TCP并发数，但是由于其采用“轮询”机制，当并发数较高时，其运行效率相当低，并可能存在I/O事件分派不均，导致部分TCP连接上的I/O出现“饥饿”现象。而如果使用epoll或AIO，则没有上述问题(早期Linux内核的AIO技术实现是通过在内核中为每个I/O请求创建一个线程来实现的，这种实现机制在高并发TCP连接的情形下使用其实也有严重的性能问题。但在最新的Linux内核中，AIO的实现已经得到改进)。</p>
<p>综上所述，在开发支持高并发TCP连接的Linux应用程序时，应尽量使用epoll或AIO技术来实现并发的TCP连接上的I/O控制，这将为提升程序对高并发TCP连接的支持提供有效的I/O保证。</p>
<p>经过这样的优化配置之后，服务器的TCP并发处理能力会显著提高。以上配置仅供参考，用于生产环境请根据自己的实际情况调整观察再调整。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[常用算法速记-Python]]></title>
        <id>https://huyuwei1996.github.io//post/chang-yong-suan-fa-su-ji-python</id>
        <link href="https://huyuwei1996.github.io//post/chang-yong-suan-fa-su-ji-python">
        </link>
        <updated>2019-09-05T15:38:26.000Z</updated>
        <content type="html"><![CDATA[<h1 id="10-十大经典排序算法">1.0 十大经典排序算法</h1>
<figure data-type="image" tabindex="1"><img src="https://www.runoob.com/wp-content/uploads/2019/03/sort.png" alt="img"></figure>
<figure data-type="image" tabindex="2"><img src="https://www.runoob.com/wp-content/uploads/2019/03/0B319B38-B70E-4118-B897-74EFA7E368F9.png" alt="img"></figure>
<h1 id="11-冒泡排序">1.1 冒泡排序</h1>
<figure data-type="image" tabindex="3"><img src="https://www.runoob.com/wp-content/uploads/2019/03/bubbleSort.gif" alt="img"></figure>
<pre><code class="language-python">def bubbleSort(arr):
    for i in range(1, len(arr)):
        for j in range(0, len(arr)-i):
            if arr[j] &gt; arr[j+1]:
                arr[j], arr[j + 1] = arr[j + 1], arr[j]
    return arr
</code></pre>
<h1 id="12-选择排序">1.2 选择排序</h1>
<figure data-type="image" tabindex="4"><img src="https://www.runoob.com/wp-content/uploads/2019/03/selectionSort.gif" alt="img"></figure>
<pre><code class="language-python">def selectionSort(arr):
    for i in range(len(arr) - 1):
        # 记录最小数的索引
        minIndex = i
        for j in range(i + 1, len(arr)):
            if arr[j] &lt; arr[minIndex]:
                minIndex = j
        # i 不是最小数时，将 i 和最小数进行交换
        if i != minIndex:
            arr[i], arr[minIndex] = arr[minIndex], arr[i]
    return arr
</code></pre>
<h1 id="13-插入排序">1.3 插入排序</h1>
<figure data-type="image" tabindex="5"><img src="https://www.runoob.com/wp-content/uploads/2019/03/insertionSort.gif" alt="img"></figure>
<pre><code class="language-python">def insertionSort(arr):
    for i in range(len(arr)):
        preIndex = i-1
        current = arr[i]
        while preIndex &gt;= 0 and arr[preIndex] &gt; current:
            arr[preIndex+1] = arr[preIndex]
            preIndex-=1
        arr[preIndex+1] = current
    return arr
</code></pre>
<h1 id="14-希尔排序">1.4 希尔排序</h1>
<figure data-type="image" tabindex="6"><img src="https://www.runoob.com/wp-content/uploads/2019/03/Sorting_shellsort_anim.gif" alt="img"></figure>
<pre><code class="language-python">def shellSort(arr):
    import math
    gap=1
    while(gap &lt; len(arr)/3):
        gap = gap*3+1
    while gap &gt; 0:
        for i in range(gap,len(arr)):
            temp = arr[i]
            j = i-gap
            while j &gt;=0 and arr[j] &gt; temp:
                arr[j+gap]=arr[j]
                j-=gap
            arr[j+gap] = temp
        gap = math.floor(gap/3)
    return arr
</code></pre>
<h1 id="15-归并排序">1.5 归并排序</h1>
<figure data-type="image" tabindex="7"><img src="https://www.runoob.com/wp-content/uploads/2019/03/mergeSort.gif" alt="img"></figure>
<pre><code class="language-python">def mergeSort(arr):
    import math
    if(len(arr)&lt;2):
        return arr
    middle = math.floor(len(arr)/2)
    left, right = arr[0:middle], arr[middle:]
    return merge(mergeSort(left), mergeSort(right))

def merge(left,right):
    result = []
    while left and right:
        if left[0] &lt;= right[0]:
            result.append(left.pop(0))
        else:
            result.append(right.pop(0));
    while left:
        result.append(left.pop(0))
    while right:
        result.append(right.pop(0));
    return result
</code></pre>
<h1 id="16-快速排序">1.6 快速排序</h1>
<figure data-type="image" tabindex="8"><img src="https://www.runoob.com/wp-content/uploads/2019/03/quickSort.gif" alt="img"></figure>
<pre><code class="language-python">def quickSort(arr, left=None, right=None):
    left = 0 if not isinstance(left,(int, float)) else left
    right = len(arr)-1 if not isinstance(right,(int, float)) else right
    if left &lt; right:
        partitionIndex = partition(arr, left, right)
        quickSort(arr, left, partitionIndex-1)
        quickSort(arr, partitionIndex+1, right)
    return arr

def partition(arr, left, right):
    pivot = left
    index = pivot+1
    i = index
    while  i &lt;= right:
        if arr[i] &lt; arr[pivot]:
            swap(arr, i, index)
            index+=1
        i+=1
    swap(arr,pivot,index-1)
    return index-1

def swap(arr, i, j):
    arr[i], arr[j] = arr[j], arr[i]
</code></pre>
<h1 id="17-堆排序">1.7 堆排序</h1>
<figure data-type="image" tabindex="9"><img src="https://www.runoob.com/wp-content/uploads/2019/03/heapSort.gif" alt="img"></figure>
<pre><code class="language-python">def buildMaxHeap(arr):
    import math
    for i in range(math.floor(len(arr)/2),-1,-1):
        heapify(arr,i)

def heapify(arr, i):
    left = 2*i+1
    right = 2*i+2
    largest = i
    if left &lt; arrLen and arr[left] &gt; arr[largest]:
        largest = left
    if right &lt; arrLen and arr[right] &gt; arr[largest]:
        largest = right

    if largest != i:
        swap(arr, i, largest)
        heapify(arr, largest)

def swap(arr, i, j):
    arr[i], arr[j] = arr[j], arr[i]

def heapSort(arr):
    global arrLen
    arrLen = len(arr)
    buildMaxHeap(arr)
    for i in range(len(arr)-1,0,-1):
        swap(arr,0,i)
        arrLen -=1
        heapify(arr, 0)
    return arr
</code></pre>
<h1 id="18-计数排序">1.8 计数排序</h1>
<figure data-type="image" tabindex="10"><img src="https://www.runoob.com/wp-content/uploads/2019/03/countingSort.gif" alt="img"></figure>
<pre><code class="language-python">def countingSort(arr, maxValue):
    bucketLen = maxValue+1
    bucket = [0]*bucketLen
    sortedIndex =0
    arrLen = len(arr)
    for i in range(arrLen):
        if not bucket[arr[i]]:
            bucket[arr[i]]=0
        bucket[arr[i]]+=1
    for j in range(bucketLen):
        while bucket[j]&gt;0:
            arr[sortedIndex] = j
            sortedIndex+=1
            bucket[j]-=1
    return arr
</code></pre>
<h1 id="19-桶排序">1.9 桶排序</h1>
<figure data-type="image" tabindex="11"><img src="https://www.runoob.com/wp-content/uploads/2019/03/Bucket_sort_1.svg_.png" alt="img"></figure>
<figure data-type="image" tabindex="12"><img src="https://www.runoob.com/wp-content/uploads/2019/03/Bucket_sort_2.svg_.png" alt="img"></figure>
<h1 id="110-基数排序">1.10 基数排序</h1>
<figure data-type="image" tabindex="13"><img src="https://www.runoob.com/wp-content/uploads/2019/03/radixSort.gif" alt="img"></figure>
<pre><code class="language-python">def radix(arr):
    
    digit = 0
    max_digit = 1
    max_value = max(arr)
    #找出列表中最大的位数
    while 10**max_digit &lt; max_value:
        max_digit = max_digit + 1
    
    while digit &lt; max_digit:
        temp = [[] for i in range(10)]
        for i in arr:
            #求出每一个元素的个、十、百位的值
            t = int((i/10**digit)%10)
            temp[t].append(i)
        
        coll = []
        for bucket in temp:
            for i in bucket:
                coll.append(i)
                
        arr = coll
        digit = digit + 1

    return arr
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[理财小白营]]></title>
        <id>https://huyuwei1996.github.io//post/li-cai-xiao-bai-ying</id>
        <link href="https://huyuwei1996.github.io//post/li-cai-xiao-bai-ying">
        </link>
        <updated>2019-09-01T15:42:51.000Z</updated>
        <content type="html"><![CDATA[<p>微信上报了个9元的课程，周末抽空补了下进度，还是尽快去补完进度，每天坚持了解一些。</p>
<h2 id="入门阅读">入门阅读</h2>
<h3 id="1小狗钱钱"><a href="https://docs.qq.com/doc/DWExvQ2ZmUGhxcmVw">1.《小狗钱钱》</a></h3>
<ul>
<li><a href="https://mp.weixin.qq.com/s/N-Al5hsUVihX0ehOy99_Hg">1.1 想变的有钱，这3个建议可以帮你</a>
<ul>
<li>1.1.1 缺钱的时候，钱就格外重要</li>
<li>1.1.2 不想一辈子就穷下去，现在就要学会理财</li>
<li>1.1.3 人的精力有限，删除干扰选项，才更有机会实现愿望</li>
<li>1.1.4 永远不要试试看，只有“做”或“不做”</li>
<li>总结
<ul>
<li>写下Top3愿望</li>
<li>制作梦想相册——激励和推动自己</li>
<li>准备梦想储蓄罐</li>
</ul>
</li>
</ul>
</li>
<li><a href="https://mp.weixin.qq.com/s/GHm4FIm82t0955xXDeK8TQ">1.2 赚钱没你想的那么难</a>
<ul>
<li>1.2.1 写“成功日记”
<ul>
<li>任何小事都可以，给自己加油、自信</li>
</ul>
</li>
<li>1.2.2 商人赚钱建议
<ul>
<li>为别人解决问题</li>
<li>把精力放在你知道的事情和能够做的事情上</li>
</ul>
</li>
<li>1.2.3 觉得钱难赚的人
<ul>
<li>没有认真思考
<ul>
<li>赚钱你要花费多少时间？</li>
</ul>
</li>
<li>不愿面对困难
<ul>
<li>找借口，放弃</li>
</ul>
</li>
</ul>
</li>
<li>总结
<ul>
<li>写“成功日记”，增加自信</li>
<li>别人需要什么？</li>
<li>我能做什么？</li>
</ul>
</li>
</ul>
</li>
<li><a href="https://mp.weixin.qq.com/s/BQ0AjU7epTCusNvL8k7Uog">1.3 99%的人不成功，都是因为它</a>
<ul>
<li>1.3.1 遇到困难的时候，越要坚持自己的想法</li>
<li>1.3.2 要每天不间断地去做对你未来意义重大的事
<ul>
<li>21天理论——坚持21天就会变成习惯</li>
</ul>
</li>
<li>1.3.3 当决定做一件事的时候，就要立即去做
<ul>
<li>否则很可能永远不会再去做</li>
</ul>
</li>
<li>总结
<ul>
<li>坚持最重要</li>
</ul>
</li>
</ul>
</li>
<li><a href="https://mp.weixin.qq.com/s/GFq6v8ZpD2-CP_YEqRT6IQ">1.4 不要杀死你的鹅</a>
<ul>
<li>1.4.1 不要杀死你的鹅
<ul>
<li>不要花光本金，否则永远不会有收益</li>
</ul>
</li>
<li>总结
<ul>
<li>负债的人应该扔掉所有信用卡
<ul>
<li>使用信用卡，总比使用现金花的多</li>
</ul>
</li>
<li>尽可能少的偿还贷款
<ul>
<li>如果是信用卡债还是建议先还债</li>
<li>还要考虑通货膨胀，以后钱会缩水</li>
</ul>
</li>
<li>对于消费贷款，应该将不用于生活的钱存起来一半，另一半用于还债
<ul>
<li>存钱，保证储蓄(本金)</li>
</ul>
</li>
<li>把想要的东西分为“必要、需要、想要”
<ul>
<li>控制消费</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="https://mp.weixin.qq.com/s/ICJtLRYf5UYkTpBjgOY8TA">1.5 投资，遵循这3个原则就足够了</a>
<ul>
<li>1.5.1 现金的重要性，应对突发情况
<ul>
<li>投资前，做好资产配置</li>
</ul>
</li>
<li>1.5.2 金钱能否带来幸福，取决于是否懂得怎样使用它</li>
<li>1.5.3 穷人思维
<ul>
<li>拿到钱买买买，吃喝玩乐，奢侈享受，忽略了投资</li>
</ul>
</li>
<li>1.5.4 富人思维
<ul>
<li>消费一些钱作为奖励，将80%甚至更多的钱投资，继续赚取更多的钱</li>
</ul>
</li>
<li>总结
<ul>
<li>投资要安全
<ul>
<li>本金不能丧失</li>
</ul>
</li>
<li>要有收益
<ul>
<li>先评估风险，再考虑收益多少</li>
</ul>
</li>
<li>充分了解投资对象
<ul>
<li>“不懂的就不要碰”</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="2晚间分享财富的载体时间量化思维"><a href="https://shimo.im/docs/660f6eab67a74f47/read">2.【晚间分享】财富的载体——时间&amp;量化思维</a></h3>
<ul>
<li>2.1 大多数人在工作和生活中，更多地注意金钱，而很少注意“时间”
<ul>
<li>有钱人会感觉时间比金钱重要，愿意用钱买时间</li>
<li>没钱的人更在乎钱，不在乎时间，愿意用时间做一些没什么价值的事情</li>
</ul>
</li>
<li>2.2 穷人思维
<ul>
<li>因为没钱，所以缓缓；等有钱了，怎样怎样</li>
<li>为免费、特价等，付出过多的资源和时间
<ul>
<li>可能浪费过多的时间和注意力</li>
</ul>
</li>
</ul>
</li>
<li>2.3 理财思维
<ul>
<li>重视时间成本</li>
</ul>
</li>
<li>2.4 不理财不等于没风险，通货膨胀其实就是最大的风险</li>
<li>2.5 “怕吃苦，吃苦一辈子，不怕苦，吃苦一阵子”</li>
<li>总结
<ul>
<li>每个人的时间都有一定的金钱价值
<ul>
<li>用凡事不要凭感觉，用量化思维计算，选择更有价值的事做</li>
</ul>
</li>
<li>金钱是有时间价值的，现在的钱比未来更值钱
<ul>
<li>提高投资能力，让钱更值钱</li>
</ul>
</li>
<li>学习是有时间成本的
<ul>
<li>学的越晚，消耗越大</li>
</ul>
</li>
</ul>
</li>
<li>拓展知识
<ul>
<li>投资的不可能三角
<ul>
<li>投资理财目标中，收益性、安全性、流动性三者，最多只能占两个
<ul>
<li>收益性、安全性、！流动性
<ul>
<li>房子</li>
</ul>
</li>
<li>安全性、流动性、！收益性
<ul>
<li>活期存款、货币基金等</li>
</ul>
</li>
<li>收益性、流动性、！安全性
<ul>
<li>部分P2P</li>
</ul>
</li>
</ul>
</li>
<li>通过投资资产的三种属性，判断投资品种是否靠谱</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="3晨读美文两种思维方式决定了你只能当穷人"><a href="https://docs.qq.com/doc/DR3ZjZHBVdk5adVBa">3.【晨读美文】两种思维方式决定了你只能当穷人</a></h3>
<h3 id="4午间茶馆小狗钱钱拆读"><a href="https://docs.qq.com/doc/DR2dRWldBR0ZQVGNp">4.【午间茶馆】《小狗钱钱》拆读</a></h3>
<h3 id="5晚间分享玩转信用卡"><a href="https://docs.qq.com/doc/DR25ZdVZkVFhRSnR1">5.【晚间分享】玩转信用卡</a></h3>
<h3 id="6晨读美文-要为你的未来花点钱"><a href="https://docs.qq.com/doc/DWGRkcEx0YWFBVGlO">6.【晨读美文】-要为你的未来花点钱</a></h3>
<p><em>XMind: ZEN - Trial Version</em><br>
<img src="https://huyuwei1996.github.io//post-images/1567352666078.png" alt=""></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[数据结构与算法-Python]]></title>
        <id>https://huyuwei1996.github.io//post/suan-fa-xue-xi-python</id>
        <link href="https://huyuwei1996.github.io//post/suan-fa-xue-xi-python">
        </link>
        <updated>2019-08-31T13:21:20.000Z</updated>
        <content type="html"><![CDATA[<h2 id="算法的五大特性">算法的五大特性</h2>
<ol>
<li>
<p><strong>输入</strong>：算法具有0个或者多个输入</p>
</li>
<li>
<p><strong>输出</strong>：算法至少有1个或者多个输出</p>
</li>
<li>
<p><strong>有穷性</strong>：算法在有限的步骤之后会自动结束而不会无线循环，并且，每一个步骤在一个可接受的时间内完成</p>
</li>
<li>
<p><strong>确定性</strong>：算法中的每一步都有确定的定义，不会出现二义性</p>
</li>
<li>
<p><strong>可行性</strong>：算法的每一步都是可行的，也就是说每一步都能够执行有限次数的完成</p>
</li>
</ol>
<h2 id="时间复杂度与大o表示法">时间复杂度与大O表示法</h2>
<ul>
<li><strong>最优时间复杂度</strong></li>
<li><strong>最坏时间复杂度</strong></li>
<li><strong>平均时间复杂度</strong></li>
</ul>
<p>主要关注算法的最坏情况，即<strong>最坏时间复杂度</strong></p>
<h3 id="时间复杂度的几条计算基本规则">时间复杂度的几条计算基本规则</h3>
<ol>
<li>
<p>基本操作，即只有常数项，认为其时间复杂度为<strong>O(1)</strong></p>
</li>
<li>
<p>顺序结构，时间复杂度按<strong>加法</strong>进行计算</p>
</li>
<li>
<p>循环结构，时间复杂度按<strong>乘法</strong>进行计算</p>
</li>
<li>
<p>分支结构，时间复杂度<strong>取最大值</strong></p>
</li>
<li>
<p>判断一个算法的效率时，往往只需要关注操作数量的<strong>最高项</strong>，其次要项和常数项可以忽略</p>
</li>
<li>
<p>在没有特殊说明时，我们所分析的算法的时间复杂度都是指<strong>最坏时间复杂度</strong></p>
</li>
</ol>
<h2 id="常见时间复杂度">常见时间复杂度</h2>
<h3 id="常见时间复杂度直接的关系">常见时间复杂度直接的关系</h3>
<p><strong>O(1) &lt; O(logn) &lt; O(n) &lt; O(nlogn) &lt; O(n<sup>2</sup>) &lt; O(n<sup>2</sup>logn) &lt; O(n<sup>3</sup>) &lt; O(2<sup>n</sup>) &lt; O(n!) &lt; O(n<sup>n</sup>)</strong></p>
<h2 id="python内置类型性能分析">Python内置类型性能分析</h2>
<h3 id="timeit模块">timeit模块</h3>
<p><strong>class timeit.Timer(stmt='pass', setup='pass', timer=&lt;timer function&gt;)</strong></p>
<p><strong>timeit.Timer.timeit(number=1000000)</strong></p>
<p>测试代码时的测试次数，默认为1000000次</p>
<h3 id="list内置操作的时间复杂度">list内置操作的时间复杂度</h3>
<h3 id="dict内置操作的时间复杂度">dict内置操作的时间复杂度</h3>
<h2 id="数据结构">数据结构</h2>
<h3 id="概念">概念</h3>
<h3 id="算法与数据结构的区别">算法与数据结构的区别</h3>
<p>程序 = 算法 + 数据结构</p>
<h3 id="抽象数据类型abstract-data-type-简称adt">抽象数据类型(Abstract Data Type 简称ADT)</h3>
<h2 id="顺序表的结构和实现">顺序表的结构和实现</h2>
<h3 id="顺序表的结构">顺序表的结构</h3>
<h3 id="顺序表的两种基本实现方式">顺序表的两种基本实现方式</h3>
<ul>
<li>一体式结构</li>
<li>分离式结构</li>
</ul>
<h3 id="元素存储区替换">元素存储区替换</h3>
<h3 id="元素存储区扩充">元素存储区扩充</h3>
<h4 id="扩充的两种策略">扩充的两种策略</h4>
<p>第二种=用空间换时间</p>
<h2 id="顺序表的操作">顺序表的操作</h2>
<h3 id="增加元素">增加元素</h3>
<h3 id="删除元素">删除元素</h3>
<h2 id="python中的顺序表">Python中的顺序表</h2>
<p>Python中的list和tuple两种类型采用了顺序表的实现技术</p>
<h3 id="list的基本实现技术">list的基本实现技术</h3>
<h2 id="链表">链表</h2>
<h3 id="单向链表">单向链表</h3>
<h4 id="操作">操作</h4>
<h4 id="实现">实现</h4>
<pre><code class="language-python">class Node(object):
    &quot;&quot;&quot;节点&quot;&quot;&quot;

    def __init__(self, item):
        self.item = item
        self.next = None


class SingleLinkList(object):
    &quot;&quot;&quot;单链表&quot;&quot;&quot;

    def __init__(self, node=None):
        self.__head = node  # 私有属性

    def is_empty(self):
        &quot;&quot;&quot;链表是否为空&quot;&quot;&quot;
        return self.__head is None

    def length(self):
        &quot;&quot;&quot;链表长度&quot;&quot;&quot;
        # cursor游标，用来移动，遍历节点
        cur = self.__head
        # count计数
        count = 0
        while cur is not None:
            count += 1
            cur = cur.next
        return count

    def travel(self):
        &quot;&quot;&quot;遍历整个链表&quot;&quot;&quot;
        # cursor游标，用来移动，遍历节点
        cur = self.__head
        while cur is not None:
            print(cur.item, end=&quot; &quot;)
            cur = cur.next
        print(&quot;&quot;)

    def add(self, item):
        &quot;&quot;&quot;链表头部添加元素，头插法&quot;&quot;&quot;
        node = Node(item)
        if self.is_empty():
            self.__head = node
        else:
            node.next = self.__head
            self.__head = node

    def append(self, item):
        &quot;&quot;&quot;链表尾部添加元素，尾插法&quot;&quot;&quot;
        node = Node(item)
        if self.is_empty():
            self.__head = node
        else:
            cur = self.__head
            while cur.next is not None:
                cur = cur.next
            cur.next = node

    def insert(self, pos, item):
        &quot;&quot;&quot;指定位置添加元素
        :param pos 位置
        &quot;&quot;&quot;
        if pos &lt;= 0:
            self.add(item)
        elif pos &gt; (self.length() - 1):
            self.append(item)
        else:
            # pre
            pre = self.__head
            count = 0
            while count &lt; (pos - 1):
                count += 1
                pre = pre.next
            # 退出循环后。pre指向pos-1位置
            node = Node(item)
            node.next = pre.next
            pre.next = node

    def remove(self, item):
        &quot;&quot;&quot;删除节点&quot;&quot;&quot;
        cur = self.__head
        pre = None
        while cur is not None:
            if cur.item == item:
                # 先判断此节点是否头节点
                if cur == self.__head:
                    self.__head = cur.next
                else:
                    pre.next = cur.next
                break
            else:
                pre = cur
                cur = cur.next

    def search(self, item):
        &quot;&quot;&quot;查找节点是否存在&quot;&quot;&quot;
        cur = self.__head
        while cur is not None:
            if cur.item == item:
                return True
            else:
                cur = cur.next
        return False


if __name__ == '__main__':
    n = Node(100)
    sll = SingleLinkList()
    print('链表是否为空', sll.is_empty())
    print('链表长度', sll.length())
    sll.append(1)
    sll.append(2)
    sll.append(3)
    sll.add(4)
    sll.insert(0, 5)
    sll.insert(5, 10)
    sll.insert(2, 7)
    print('链表是否为空', sll.is_empty())
    print('链表长度', sll.length())
    sll.travel()
    print('查找节点是否存在', sll.search(1))
    sll.remove(5)
    sll.travel()
    sll.remove(10)
    sll.travel()
    sll.remove(2)
    sll.travel()

</code></pre>
<h4 id="链表与顺序表对比">链表与顺序表对比</h4>
<h3 id="双向链表">双向链表</h3>
<h4 id="操作-2">操作</h4>
<h4 id="实现-2">实现</h4>
<pre><code class="language-python">class DoubleNode(object):
    &quot;&quot;&quot;节点&quot;&quot;&quot;

    def __init__(self, item):
        self.item = item
        self.next = None
        self.prev = None


class DoubleLinkList(object):
    &quot;&quot;&quot;双向链表&quot;&quot;&quot;

    def __init__(self, node=None):
        self.__head = node  # 私有属性

    def is_empty(self):
        &quot;&quot;&quot;链表是否为空&quot;&quot;&quot;
        return self.__head is None

    def length(self):
        &quot;&quot;&quot;链表长度&quot;&quot;&quot;
        # cursor游标，用来移动，遍历节点
        cur = self.__head
        # count计数
        count = 0
        while cur is not None:
            count += 1
            cur = cur.next
        return count

    def travel(self):
        &quot;&quot;&quot;遍历整个链表&quot;&quot;&quot;
        # cursor游标，用来移动，遍历节点
        cur = self.__head
        while cur is not None:
            print(cur.item, end=&quot; &quot;)
            cur = cur.next
        print(&quot;&quot;)

    def add(self, item):
        &quot;&quot;&quot;链表头部添加元素，头插法&quot;&quot;&quot;
        node = DoubleNode(item)
        # # function 1
        # node.next = self.__head
        # self.__head = node
        # node.next.prev = node

        # function 2
        node.next = self.__head
        self.__head.prev = node
        self.__head = node

    def append(self, item):
        &quot;&quot;&quot;链表尾部添加元素，尾插法&quot;&quot;&quot;
        node = DoubleNode(item)
        if self.is_empty():
            self.__head = node
        else:
            cur = self.__head
            while cur.next is not None:
                cur = cur.next
            cur.next = node
            node.prev = cur

    def insert(self, pos, item):
        &quot;&quot;&quot;指定位置添加元素
        :param pos 位置
        &quot;&quot;&quot;
        if pos &lt;= 0:
            self.add(item)
        elif pos &gt; (self.length() - 1):
            self.append(item)
        else:
            cur = self.__head
            count = 0

            while count &lt; pos:
                count += 1
                cur = cur.next
            node = DoubleNode(item)
            node.next = cur
            node.prev = cur.prev
            # function 1
            cur.prev.next = node
            cur.prev = node

            # # function 2
            # cur.prev = node
            # cur.prev.next = node

    def remove(self, item):
        &quot;&quot;&quot;删除节点&quot;&quot;&quot;
        cur = self.__head
        while cur is not None:
            if cur.item == item:
                # 判断是否头节点
                if cur == self.__head:
                    self.__head = cur.next
                    if cur.next:
                        # 判断链表是否只有一个节点
                        cur.next.prev = None
                else:
                    cur.prev.next = cur.next
                    if cur.next:
                        cur.next.prev = cur.prev
                break
            else:
                cur = cur.next

    def search(self, item):
        &quot;&quot;&quot;查找节点是否存在&quot;&quot;&quot;
        cur = self.__head
        while cur is not None:
            if cur.item == item:
                return True
            else:
                cur = cur.next
        return False


if __name__ == '__main__':
    n = DoubleNode(100)
    dll = DoubleLinkList()
    print('链表是否为空', dll.is_empty())
    print('链表长度', dll.length())
    dll.append(1)
    dll.append(2)
    dll.append(3)
    dll.add(4)
    dll.insert(0, 5)
    dll.insert(5, 10)
    dll.insert(2, 7)
    print('链表是否为空', dll.is_empty())
    print('链表长度', dll.length())
    dll.travel()
    dll.remove(2)
    dll.travel()
    dll.remove(5)
    dll.travel()
    dll.remove(10)
    dll.travel()
    print('查找节点是否存在', dll.search(1))

</code></pre>
<h3 id="单项循环链表">单项循环链表</h3>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[git设置/取消代理]]></title>
        <id>https://huyuwei1996.github.io//post/git-push-man</id>
        <link href="https://huyuwei1996.github.io//post/git-push-man">
        </link>
        <updated>2019-08-30T16:32:04.000Z</updated>
        <content type="html"><![CDATA[<p>git设置代理<br>
git config --global https.proxy socks5://127.0.0.1:1086<br>
git config --global http.proxy socks5://127.0.0.1:1086<br>
git取消代理<br>
git config --global --unset https.proxy<br>
git config --global --unset http.proxy</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[ Locust & Jmeter 对比]]></title>
        <id>https://huyuwei1996.github.io//post/locust-and-jmeter-dui-bi</id>
        <link href="https://huyuwei1996.github.io//post/locust-and-jmeter-dui-bi">
        </link>
        <updated>2019-08-30T15:52:39.000Z</updated>
        <summary type="html"><![CDATA[<blockquote>
<p>转自——Locust 源码阅读及特点思考 (三)：<a href="https://testerhome.com/topics/11853">https://testerhome.com/topics/11853</a></p>
</blockquote>
]]></summary>
        <content type="html"><![CDATA[<blockquote>
<p>转自——Locust 源码阅读及特点思考 (三)：<a href="https://testerhome.com/topics/11853">https://testerhome.com/topics/11853</a></p>
</blockquote>
<!-- more -->
<p>github：<a href="https://github.com/locustio/locust">https://github.com/locustio/locust</a></p>
<h2 id="性能测试工具一般如何实现">性能测试工具一般如何实现</h2>
<h3 id="1用例生成">1.用例生成</h3>
<p>一般两种方式，手写脚本和录制用例。<br>
脚本可以是各种格式各种形式的，比如HttpRunner的YAML，Jmeter的jmx/xml，或者Locust的python代码。<br>
录制用例一般使用抓包工具或者自己内含抓包实现（Pcap4j），抓取网络包（TCP/UDP）再自己解析包内容使其成为可以识别的形式。<br>
用例录制后如果要保存，要保存成指定脚本的样式，这样才能在工具中复用。</p>
<p>用例最好是支持多种协议的，其中Http(s)协议，TCP协议最常用。</p>
<h3 id="2用例回放">2.用例回放</h3>
<p>如果回放一次，可以说是接口测试。<br>
如果回放N次，可以说是性能测试。<br>
这时需要配置一些性能测试指标如用户数、步长、思考时间等，不多解释。<br>
总体是将一个压力请求复制N份，然后在指定时间（步长）内，将这些请求发出去。<br>
Java的复制，可以是创建多个线程实现。<br>
Locust的复制，是复制多个用例，放到数组里，然后再弹出去（请求）。</p>
<h3 id="3结果实时显示">3.结果实时显示</h3>
<p>使用绘图工具实现。<br>
一般是一段时间（1秒或者几百毫秒）间隔的用例回放的某个返回数据的平均值，将其在图上打点，然后之前的点再和这个点连起来。<br>
这个工作一般都是开源的绘图工具实现的。<br>
Locust的实现是前端的，在 chart.js 中，LocustLineChart，还是比较简陋的。<br>
Jmeter的可以安装插件显示，也简陋。</p>
<p>除此之外，还需要实时显示错误日志。</p>
<h3 id="4压力机和服务端性能指标监控">4.压力机和服务端性能指标监控</h3>
<p>方式很多，可以是shell脚本监控，专门的监控软件监控，自己实现的程序监控。<br>
可以是在被压测的服务器端运行客户端程序，将指定的监控指标传给master节点，绘图。<br>
或者直接zabbix等专业的监控。<br>
服务器端的性能监控还会包含更多，如pinpoint，CAT等等较专业的。<br>
Jmeter也是安装插件实现，简陋。<br>
Locust就没有。</p>
<h3 id="5测试报告生成">5.测试报告生成</h3>
<p>用例回放的结果，会保存起来，可以保存在内存，文件，NoSQL，数据库中。<br>
文件可以是csv格式。<br>
NoSQL可以是Redis，Mongodb等<br>
数据库就太多了，常用是InfluxDB，MySQL。<br>
然后生成报告时，将这些数据读出来，绘图，加工，成为报告。<br>
Locust也没有这部分功能。<br>
Jmeter3.0开始支持报告生成，但是有硬伤。</p>
<h2 id="从上述实现看locust和jmeter">从上述实现看Locust和Jmeter</h2>
<h3 id="1用例生成-2">1.用例生成</h3>
<p>python脚本是亮点，毕竟代码可以实现一切需求。<br>
但不足之处很明显：<br>
1.util包没有，复杂用例编写代码工作量很大，维护成本很大，同时考验代码功力。<br>
2.没有录制用例，保存用例功能，即便使用HttpRunner支持的录制保存，也只是基础用例。<br>
实际上性能测试刚需的如参数化，还是要手写python脚本。<br>
以上对于时间较紧的测试需求，用Locust明显是撞墙。</p>
<p>Jmeter明显好很多，本身GUI界面简单明了，各种内置函数帮助你写脚本。<br>
就算用例编写很复杂，还提供了beanshell，可以使用Java代码实现（虽然调试比较费劲）。<br>
同时Jmeter拥有各种协议的插件，还是不错的。</p>
<h3 id="2用例回放-2">2.用例回放</h3>
<p>Locust存在硬伤，因为是python+协程实现，性能很弱。<br>
我自测过，4个逻辑核的联想笔记本，Locust使用4个slave，造成的压力是1.3k，Jmeter是13k，差了10倍。</p>
<h3 id="3结果实时显示-2">3.结果实时显示</h3>
<p>Locust比Jmeter更亲切一点，半斤八两。<br>
解释一下为什么说半斤八两。<br>
简单几百几千个请求的情况就不说了，性能测试对压测时间压测的量是有要求的，百万上亿的请求不是事儿。<br>
这时候对压测图形的要求就比较高了，最理想的是可以看到每个细节，不能秘密麻麻的看都看不清，那无法定位问题。</p>
<h3 id="4压力机和服务端性能指标监控-2">4.压力机和服务端性能指标监控</h3>
<p>Locust压根没有，Jmeter是有但是和没有差不多。<br>
这个没什么，服务器的性能监控越来越复杂，不好监控。<br>
LoadRunner的服务器性能指标监控是非常棒的，确实专业。</p>
<h3 id="5测试报告生成-2">5.测试报告生成</h3>
<p>Locust压根没有，Jmeter3.0开始有，并且还可以接受。<br>
Jmeter报告的硬伤：报告来源于分析日志，日志格式是csv的，平均10000个请求占用1MB的空间。<br>
如果请求数上千万，日志就非常大了，生成报告可以卡死。</p>
<p>测试报告非常重要：<br>
1.有的产品是必须要测试报告的，Locust直接PASS。<br>
2.没测试报告文件，很难回复测试结果，不够直观也很容易解释不清楚。</p>
<p>理想的测试报告是最好有结论的，领导最喜欢的就是直观，一句话告诉我性能行不行。<br>
如果有性能截图的话，领导的问题往往非常直接，比如：这里怎么下去了，这里怎么上去了等等，非常便于讨论问题。<br>
如果都是乱糟糟的文字描述，太费劲。</p>
<h2 id="从实现评价locust">从实现评价Locust</h2>
<p>能用，但不实用。</p>
<h2 id="工作中典型场景看locust">工作中典型场景看Locust</h2>
<h3 id="领导测一下这个httpget接口顺便做一下性能测试压力不用太大">领导：测一下这个http/get接口，顺便做一下性能测试，压力不用太大。</h3>
<p>Locust：先用postman测试基本功能，后写python脚本压测，参数化实现工作量较大，如果领导突然说压力要大一点儿，Locust就不行了。<br>
Jmeter：全部使用Jmeter测试，根本不用担心压力多大，接口测试的简单边界Jmeter也能胜任。</p>
<h3 id="领导测一下这个页面性能看看能支撑多少用户rps-访问">领导：测一下这个页面性能，看看能支撑多少用户/RPS 访问。</h3>
<p>Locust：基本抓瞎。</p>
<ol>
<li>使用 fiddler/charles 看页面请求，过滤掉静态资源，为每一个请求写脚本（HttpRunner的录制生成）。</li>
<li>如果有服务器状态标识如session/token，或者postman额外请求，或者chrome开发者工具找到对应内容，手工保存。</li>
<li>最好没有参数化部分，要不然脚本改动很大。</li>
<li>请求太多可能会造成压力分配有限，Locust可能不能胜任。</li>
<li>如果领导需要加上静态资源，生成脚本动作重新来一遍。</li>
</ol>
<p>Jmeter：</p>
<ol>
<li>自身录制请求，软件内过滤静态资源较方便，每个请求都会录制好，手动操作很少。</li>
<li>不用额外postman，Jmeter自身就胜任各种请求，同时sesson内容（id）或者token直接使用参数化保存在Jmeter内部，少去手工保存动作。</li>
<li>无所谓参数化，很简单。</li>
<li>压力足够。</li>
<li>如果要加静态资源，亮化静态请求即可。 同时，加http头信息非常方便。</li>
</ol>
<h3 id="领导测试报告导出来看一下">领导：测试报告导出来看一下。</h3>
<p>Locust：what？<br>
Jmeter：稍等，马上。</p>
<h3 id="领导增加并发并发不够看不出问题">领导：增加并发，并发不够看不出问题。</h3>
<p>Locust：给我几台虚拟机<br>
Jmeter：哦，好的。</p>
<h2 id="locust的优势">Locust的优势</h2>
<p>要改造成Jmeter的程度几乎是不可能的，Jmeter多少人在维护多少人在用，Locust几个人维护几个人在用，几乎是无底洞。</p>
<ul>
<li>非Java语言说出去好听，</li>
<li>语言特性，工作不需要Jmeter那么多的话，开发起来会比较快。</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[SQL学习]]></title>
        <id>https://huyuwei1996.github.io//post/sql-xue-xi</id>
        <link href="https://huyuwei1996.github.io//post/sql-xue-xi">
        </link>
        <updated>2019-08-30T13:38:25.000Z</updated>
        <summary type="html"><![CDATA[<h3 id="mysql80客户端连接报错">mysql8.0客户端连接报错</h3>
<p>原因: caching_sha2_password, 是mysql8.0的一个新特性, 默认使用该身份认证插件进行加密. 但是一些客户端, 诸如sequel pro, Navicat 不支持这种插件, 这个时候就会出现如上错误.</p>
]]></summary>
        <content type="html"><![CDATA[<h3 id="mysql80客户端连接报错">mysql8.0客户端连接报错</h3>
<p>原因: caching_sha2_password, 是mysql8.0的一个新特性, 默认使用该身份认证插件进行加密. 但是一些客户端, 诸如sequel pro, Navicat 不支持这种插件, 这个时候就会出现如上错误.</p>
<!-- more -->
<blockquote>
<p>在终端登录mysql -uroot -p账户密码</p>
</blockquote>
<pre><code class="language-sql">#修改加密规则 
mysql&gt; ALTER USER 'root'@'localhost' IDENTIFIED BY 'password' PASSWORD EXPIRE NEVER;
Query OK, 0 rows affected (0.00 sec)
#更新用户密码
mysql&gt;  ALTER USER 'root'@'localhost' IDENTIFIED WITH mysql_native_password BY 'password';
Query OK, 0 rows affected (0.00 sec)
#刷新权限
mysql&gt; FLUSH PRIVILEGES;
Query OK, 0 rows affected (0.00 sec)
#修改用户密码
mysql&gt; alter user 'root'@'localhost' identified by '要设置的账户密码';
Query OK, 0 rows affected (0.00 sec)
</code></pre>
<h3 id="测试版sequelpro地址">测试版sequelpro地址</h3>
<p><a href="https://sequelpro.com/test-builds">https://sequelpro.com/test-builds</a></p>
<h3 id="mac平台">mac平台：</h3>
<p>Sequel Pro</p>
<h3 id="其他平台">其他平台：</h3>
<p>MySQL Workbench</p>
<h3 id="学习sql练习网站">学习sql练习网站</h3>
<p><a href="https://sqlbolt.com">https://sqlbolt.com</a></p>
<p>todo：Exercise 6</p>
]]></content>
    </entry>
</feed>